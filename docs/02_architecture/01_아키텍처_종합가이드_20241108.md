# CXG 플랫폼 - 아키텍처 종합가이드

> **CXG 플랫폼의 완벽한 아키텍처 참고자료**
> - **대상 독자**: 아키텍트, 시니어 개발자, 테크 리드
> - **읽는 시간**: 1-2시간
> - **마지막 업데이트**: 2024년 11월 8일

---

## 목차

1. [아키텍처 개요](#아키텍처-개요)
2. [시스템 설계 패턴](#시스템-설계-패턴)
3. [멀티테넌트 아키텍처](#멀티테넌트-아키텍처)
4. [데이터베이스 아키텍처](#데이터베이스-아키텍처)
5. [권한 및 인증 모델](#권한-및-인증-모델)
6. [프론트엔드 아키텍처](#프론트엔드-아키텍처)
7. [API 아키텍처](#api-아키텍처)
8. [보안 아키텍처](#보안-아키텍처)
9. [확장성 및 성능](#확장성-및-성능)
10. [배포 아키텍처](#배포-아키텍처)
11. [기술 스택 참고자료](#기술-스택-참고자료)

---

## 아키텍처 개요

### 비전

CXG 플랫폼은 50명 미만의 중소기업(SME)을 지원하기 위해 설계된 **모듈식 모놀리스**입니다. 아키텍처는 다음을 강조합니다:

- **격리**: 멀티테넌트 데이터 분리
- **모듈성**: 독립적인 비즈니스 도메인 모듈
- **확장성**: 수평 및 수직 확장 지원
- **보안**: 엔터프라이즈급 보안 및 준수
- **개발자 경험**: 명확한 패턴과 도구

### 시스템 구성 요소

```
┌─────────────────────────────────────────────────────────┐
│                    프레젠테이션 계층                     │
│  ┌──────────────────┬─────────────┬─────────────────┐  │
│  │  매니저 웹       │ 테넌트 웹   │  모바일 (향후) │  │
│  │  (Next.js 15)    │ (Next.js 15)│                 │  │
│  └──────────────────┴─────────────┴─────────────────┘  │
└──────────────────────┬──────────────────────────────────┘
                       │ REST API
┌──────────────────────▼──────────────────────────────────┐
│                    API 계층                              │
│     FastAPI + SQLAlchemy + Pydantic                    │
│     - 라우트 핸들러                                     │
│     - 미들웨어 (인증, 로깅, CORS)                       │
│     - 에러 처리 및 검증                                 │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│              비즈니스 로직 계층                          │
│     서비스 + 도메인 모델 + 비즈니스 규칙               │
│     - 기능 구현                                         │
│     - 복잡한 워크플로우                                 │
│     - 도메인 간 로직                                    │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│              데이터 접근 계층                            │
│     Repository + ORM (SQLAlchemy)                      │
│     - 쿼리 추상화                                       │
│     - 데이터 변환                                       │
│     - 캐싱 계층                                         │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│              데이터 계층                                 │
│  ┌─────────────────┬────────────────┬────────────────┐ │
│  │  매니저 DB      │  테넌트 DB     │   Redis 캐시   │ │
│  │  (PostgreSQL)   │  (PostgreSQL)   │                │ │
│  └─────────────────┴────────────────┴────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 주요 아키텍처 원칙

| 원칙 | 구현 | 이점 |
|------|------|------|
| **공존 배치** | 도메인별 라우터, 서비스, 스키마, 모델을 함께 배치 | 유지보수 용이, 명확한 소유권 |
| **단일 책임** | 각 모듈은 하나의 비즈니스 도메인 처리 | 독립적 확장, 명확한 경계 |
| **멀티테넌시** | 물리적 + 논리적 격리 | 강력한 데이터 보안, 비용 효율 |
| **비동기 우선** | FastAPI 비동기, TanStack Query 상태 관리 | 더 나은 성능, 반응형 UX |
| **타입 안전성** | TypeScript + Pydantic + mypy | 런타임 오류 감소, 더 나은 개발 경험 |
| **명확한 계약** | Envelope 응답, 버전 지정된 API | 예측 가능한 통합, 쉬운 진화 |

---

## 시스템 설계 패턴

### 1. 계층 아키텍처

각 요청은 5계층 패턴을 따릅니다:

```
요청
  ↓
[프레젠테이션 계층] - 웹 UI (React 컴포넌트)
  ↓ HTTP
[API 계층] - 라우트 핸들러 (FastAPI)
  ↓ 내부 호출
[비즈니스 로직 계층] - 서비스 (비즈니스 규칙)
  ↓ 내부 호출
[데이터 접근 계층] - Repository (ORM 쿼리)
  ↓ SQL
[데이터베이스] - 지속적 저장
```

**계층 책임:**
- **프레젠테이션**: 사용자 인터페이스, 폼 처리, 상태 관리
- **API**: HTTP 엔드포인트 라우팅, 검증, 응답 포맷팅
- **비즈니스 로직**: 기능 구현, 워크플로우, 계산
- **데이터 접근**: ORM 쿼리, 캐싱, 트랜잭션 관리
- **데이터베이스**: 스키마, 제약 조건, 데이터 지속성

### 2. 공존 배치 패턴

백엔드 모듈 구조:

```
apps/backend-api/src/api/
├── routers/
│   └── [module]/
│       ├── __init__.py (내보내기)
│       ├── router.py (FastAPI 라우트)
│       ├── service.py (비즈니스 로직)
│       └── [하위 라우터]
├── schemas/
│   └── [module]/
│       ├── __init__.py
│       └── [entity]_schema.py (Pydantic 모델)
├── models/
│   └── [module]/
│       ├── __init__.py
│       └── [entity]_model.py (SQLAlchemy ORM)
└── utils/
    └── [유틸리티 파일]
```

관련 코드를 함께 그룹화:
- `router.py`: HTTP 라우팅 처리
- `service.py`: 비즈니스 로직 구현
- `schema.py`: 요청/응답 계약 정의
- `model.py`: ORM 정의

### 3. Repository 패턴

데이터 접근 추상화:

```python
# 서비스 계층은 데이터베이스를 직접 쿼리하지 않음
class UserService:
    def __init__(self, db: Session):
        self.db = db

    def get_user(self, user_id: int):
        return self.db.query(User).filter(User.id == user_id).first()

# 이점:
# - 테스트 용이 (repository 모킹)
# - 데이터베이스 독립적
# - 캐싱 전략 중앙화
```

### 4. Envelope 응답 패턴

모든 API 응답은 이 구조를 따릅니다:

```json
{
  "success": true,
  "data": {
    "id": 1,
    "name": "John Doe"
  },
  "error": null
}
```

이점:
- **일관성**: 모든 엔드포인트가 동일한 구조
- **예측 가능성**: 클라이언트가 예상할 수 있는 것을 알 수 있음
- **정보성**: 오류 세부 정보 포함
- **확장성**: 메타데이터, 페이지 정보 추가 가능

---

## 멀티테넌트 아키텍처

### 전략: 테넌트당 데이터베이스

```
┌────────────────────────────────────────────┐
│         매니저 데이터베이스 (공유)         │
│  - 플랫폼 운영                             │
│  - 테넌트 메타데이터 & 라이선싱            │
│  - 사용자 인증 (매니저 운영자)             │
│  - 청구 & 구독                             │
└────────────────────────────────────────────┘
           │
    ┌──────┴──────┬──────────────┬──────────────┐
    │             │              │              │
┌───▼──┐    ┌────▼──┐    ┌─────▼───┐    ┌────▼───┐
│테넌트│    │테넌트 │    │ 테넌트  │    │테넌트  │
│ DB 1 │    │ DB 2  │    │  DB 3   │    │  DB N  │
│(Pg)  │    │(Pg)   │    │ (Pg)    │    │ (Pg)   │
└──────┘    └───────┘    └─────────┘    └────────┘
```

### 격리 수준

**물리적 격리**
- 테넌트당 별도의 PostgreSQL 데이터베이스
- 완벽한 데이터 분리
- 더 강한 보안
- 독립적 확장 가능

**논리적 격리**
- 행 수준 보안(RLS) 정책
- 모든 테이블에 tenant_id
- 애플리케이션 수준 강화
- 작은 배포를 위해 비용 효율적

### 테넌트 컨텍스트 흐름

```
1. 사용자 로그인 (매니저 웹)
   ↓
2. 인증 (IDAM 시스템)
   → tenant_id가 포함된 JWT 생성
   ↓
3. JWT를 포함한 API 요청
   ↓
4. 미들웨어가 tenant_id 추출
   → 적절한 테넌트 DB에 연결
   ↓
5. 모든 쿼리는 자동으로 테넌트로 범위 지정
   ↓
6. 사용자에게 응답 (범위 지정된 데이터만)
```

---

## 데이터베이스 아키텍처

### 매니저 데이터베이스 스키마

**핵심 테이블 (IDAM - 신원 및 접근 관리)**
```
┌─────────────┐
│ idam.users  │  플랫폼 운영자
├─────────────┤
│ id (PK)     │
│ username    │
│ email       │
│ password    │
│ is_active   │
└─────────────┘

┌─────────────────┐
│ idam.roles      │  역할 정의
├─────────────────┤
│ id (PK)         │
│ code (UNIQUE)   │
│ name            │
│ description     │
└─────────────────┘

┌──────────────────────────┐
│ idam.user_roles          │  다대다
├──────────────────────────┤
│ user_id (FK)             │
│ role_id (FK)             │
│ expires_at (nullable)    │  임시 할당
└──────────────────────────┘
```

**테넌트 관리 (TNNT)**
```
┌───────────────┐
│ tnnt.tenants  │  SaaS 고객
├───────────────┤
│ id (PK)       │
│ name          │
│ slug          │
│ status        │
│ created_at    │
└───────────────┘
```

### 테넌트 데이터베이스 스키마

각 테넌트 데이터베이스에는 모든 비즈니스 모듈이 포함됨:

```
┌─────────────────────────────────────────┐
│ 시스템 (SYS) - 핵심 관리                │
│  - sys.users (테넌트 사용자)             │
│  - sys.departments                      │
│  - sys.roles (테넌트 특정 역할)          │
│  - sys.permissions                      │
│  - sys.audit_logs                       │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 비즈니스 모듈                            │
│  - psm: 인사 관리                        │
│  - srm: 매출 및 수익 관리               │
│  - ivm: 재고 관리                       │
│  - lwm: 물류 및 창고                    │
│  - csm: 고객 서비스                     │
│  - asm: 자산 관리                       │
│  - fim: 시설 관리                       │
│  - bim: 예산 및 비용                    │
│  - adm: 관리                             │
│  - com: 통신                             │
│  - 기타...                               │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│ 감사 및 준수                             │
│  - [module].audit_logs (모든 테이블)     │
│  - [module].change_logs                 │
│  - sys.user_login_logs                  │
└─────────────────────────────────────────┘
```

### 주요 데이터베이스 설계 결정

| 결정 | 근거 | 트레이드오프 |
|------|------|-----------|
| **모든 테이블에 tenant_id** | 쉬운 필터링, RLS 지원 | 약간의 성능 오버헤드 |
| **소프트 삭제 (is_deleted)** | 감사 추적, 데이터 복구 | 추가 WHERE 절 |
| **감사 필드 (created_by, updated_by)** | 준수, 책임성 | 스키마 복잡성 |
| **외래 키** | 데이터 무결성 | 마이그레이션 복잡성 |
| **외래 키 인덱싱** | 쿼리 성능 | 저장소 오버헤드 |

---

## 권한 및 인증 모델

### 3계층 권한 시스템

```
┌─────────────────────────────────────────────┐
│ 계층 1: 플랫폼 수준 (매니저 DB)             │
│ - 매니저 시스템 접근 (IDAM)                │
│ - 모든 테넌트 관리 가능                     │
│ - 플랫폼 관리자가 할당                     │
└─────────────────────────────────────────────┘
           │
           ↓
┌─────────────────────────────────────────────┐
│ 계층 2: 테넌트 수준 (매니저 DB)             │
│ - 테넌트 메타데이터 접근                    │
│ - 테넌트 구성                               │
│ - 매니저 관리자가 할당                      │
└─────────────────────────────────────────────┘
           │
           ↓
┌─────────────────────────────────────────────┐
│ 계층 3: 모듈 수준 (테넌트 DB)               │
│ - 비즈니스 운영 접근                        │
│ - 모듈 특정 권한                            │
│ - 테넌트 관리자가 할당                      │
└─────────────────────────────────────────────┘
```

### 권한 모델: RBAC + 컨텍스트 인식

```python
# 권한 코드 구조
"manager:tenant:create"  # 매니저 시스템
"tenant:user:read"       # 테넌트 시스템

# 역할 계층
Manager Admin
  ├── 모든 테넌트 관리 가능
  ├── 테넌트 관리자에게 역할 할당
  └── 플랫폼 전체 분석 보기

Tenant Admin
  ├── 테넌트 사용자 관리 가능
  ├── 테넌트 내 역할 할당
  └── 테넌트 구성 관리

사용자 (특정 역할 포함)
  ├── ADM_ADMIN - 관리 모듈 접근
  ├── PSM_MANAGER - 인사 관리
  ├── SRM_VIEWER - 판매 읽기 전용
  └── 기타...
```

---

## 프론트엔드 아키텍처

### 프로젝트 구조

```
apps/manager-web/
├── app/
│   ├── (auth)/              # 인증 라우트 (공개)
│   │   ├── login/
│   │   └── register/
│   ├── (app)/               # 애플리케이션 라우트 (보호됨)
│   │   ├── dashboard/
│   │   ├── [schema]/
│   │   │   ├── [entity]/
│   │   │   │   ├── page.tsx        # 목록 페이지
│   │   │   │   ├── [id]/
│   │   │   │   │   └── page.tsx    # 상세 페이지
│   │   │   │   └── create/
│   │   │   │       └── page.tsx    # 생성 페이지
│   │   │   └── layout.tsx
│   │   └── layout.tsx
│   ├── api/                 # API 라우트 핸들러
│   └── layout.tsx
├── components/
│   ├── ui/                  # 재사용 가능한 UI 컴포넌트 (shadcn/ui)
│   ├── features/            # 기능 특정 컴포넌트
│   └── layout/              # 레이아웃 컴포넌트
├── lib/                     # 유틸리티 함수
├── hooks/                   # 커스텀 React 훅
├── services/                # API 클라이언트 함수
├── store/                   # Zustand 상태 스토어
├── types/                   # TypeScript 타입 정의
└── constants/               # 상수 및 열거형
```

### 4계층 컴포넌트 아키텍처

```
┌──────────────────────────────────┐
│ 페이지 (app/[schema]/[entity])   │
│ - 라우트 컴포넌트                │
│ - 페이지 레이아웃                │
└──────────┬───────────────────────┘
           │
┌──────────▼───────────────────────┐
│ 컴포넌트                          │
│ - 기능 UI 요소                    │
│ - 폼, 테이블, 모달               │
│ - 더 작은 것의 구성               │
└──────────┬───────────────────────┘
           │
┌──────────▼───────────────────────┐
│ 훅 (커스텀)                       │
│ - 로직 추출                       │
│ - 상태 관리                       │
│ - 부작용 처리                     │
└──────────┬───────────────────────┘
           │
┌──────────▼───────────────────────┐
│ 서비스 (API 계층)                 │
│ - API 호출 (axios)                │
│ - 타입 안전 요청/응답             │
│ - 에러 처리                       │
└───────────────────────────────────┘
```

### 상태 관리 전략

**로컬 상태** (React 훅)
```typescript
const [isOpen, setIsOpen] = useState(false);  // UI 토글
const [count, setCount] = useState(0);        // 간단한 카운터
```

**서버 상태** (TanStack Query)
```typescript
// API 데이터 캐싱, 리페치 처리, 뮤테이션
const { data, isLoading, error } = useQuery({
  queryKey: ['users', userId],
  queryFn: () => api.getUser(userId)
});
```

**글로벌 UI 상태** (Zustand)
```typescript
// 사용자 선호도, 테마, 필터
const useStore = create((set) => ({
  theme: 'light',
  setTheme: (theme) => set({ theme })
}));
```

---

## API 아키텍처

### RESTful 설계

**URL 구조**
```
/api/{version}/{system}/{module}/{resource}/{id?}/{action?}

예:
GET     /api/v1/manager/idam/users           # 사용자 목록
GET     /api/v1/manager/idam/users/123       # 특정 사용자
POST    /api/v1/manager/idam/users           # 사용자 생성
PUT     /api/v1/manager/idam/users/123       # 사용자 업데이트
DELETE  /api/v1/manager/idam/users/123       # 사용자 삭제

GET     /api/v1/tenants/{tenant}/psm/employees        # 직원 목록
GET     /api/v1/tenants/{tenant}/psm/employees/456    # 직원 조회
```

### 응답 포맷

**성공 응답**
```json
{
  "success": true,
  "data": {
    "id": 1,
    "name": "John Doe",
    "email": "john@example.com"
  },
  "error": null
}
```

**목록 응답**
```json
{
  "success": true,
  "data": {
    "items": [...],
    "total": 100,
    "page": 1,
    "per_page": 20
  },
  "error": null
}
```

**오류 응답**
```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Email is required",
    "details": [
      {
        "field": "email",
        "message": "This field is required"
      }
    ]
  }
}
```

---

## 보안 아키텍처

### 인증

```
┌─────────────────────────────────┐
│ 매니저 웹 (플랫폼 관리자)        │
│ 1. 사용자명/비밀번호로 로그인   │
│ 2. 백엔드가 검증 (bcrypt)       │
│ 3. JWT 발급 (접근 + 새로고침)   │
│ 4. 브라우저가 토큰 저장 (보안)   │
│ 5. 후속 요청에 JWT 포함         │
└─────────────────────────────────┘
```

**토큰 구조 (JWT)**
```
Header:
{
  "alg": "HS256",
  "typ": "JWT"
}

Payload:
{
  "sub": "user_123",           # 사용자 ID
  "tenant_id": "tenant_456",   # 현재 테넌트
  "roles": ["ADMIN", "USER"],  # 사용자 역할
  "iat": 1704067200,           # 발급 시간
  "exp": 1704070800            # 만료 시간
}

Signature: HMACSHA256(header + payload + SECRET)
```

### 인증 및 접근 제어

```
┌──────────────────────────────────────────┐
│ 각 API 요청 전에                         │
├──────────────────────────────────────────┤
│ 1. 미들웨어가 JWT 서명 검증             │
│ 2. 토큰 만료 여부 확인                   │
│ 3. 현재 테넌트의 사용자 역할 로드       │
│ 4. 해당 역할의 권한 로드                 │
│ 5. 요청된 작업에 대한 권한 확인         │
│ 6. RLS(행 수준 보안) 적용               │
│ 7. 승인되면 진행, 거부되면 거부         │
└──────────────────────────────────────────┘
```

### 주요 보안 실무

| 실무 | 구현 | 이유 |
|------|------|------|
| **비밀번호 해싱** | bcrypt와 salt | 위반 시 보호 |
| **HTTPS/TLS** | 모든 API 엔드포인트 | 중간자 공격 방지 |
| **CORS** | 신뢰할 수 있는 도메인 화이트리스트 | XSS 방지 |
| **CSRF 토큰** | 폼 제출 검증 | 사이트 간 공격 방지 |
| **속도 제한** | API 엔드포인트 제한 | 남용 방지 |
| **입력 검증** | Pydantic 스키마 | SQL 주입 방지 |
| **SQL 매개변수화** | ORM 쿼리만 | 데이터베이스 보안 |
| **감사 로깅** | 모든 민감한 작업 로그 | 준수 & 사건 대응 |

---

## 확장성 및 성능

### 수평 확장

**무상태 백엔드 서비스**
```
로드 밸런서
  ├─→ API 인스턴스 1
  ├─→ API 인스턴스 2
  ├─→ API 인스턴스 3
  └─→ API 인스턴스 N
```

**이점**: 부하 증가에 대응하기 위해 더 많은 인스턴스 추가

### 수직 확장

**데이터베이스 최적화**
- 자주 쿼리되는 열에 인덱싱
- EXPLAIN을 통한 쿼리 최적화
- 연결 풀링 (PgBouncer)
- 보고용 읽기 복제본

### 캐싱 전략

```
수준 1: 브라우저 캐시
  ↓ (HTTP Cache-Control)
수준 2: CDN 캐시
  ↓ (CloudFront, Cloudflare)
수준 3: 애플리케이션 캐시
  ↓ (Redis, 메모리 내)
수준 4: 데이터베이스 쿼리 캐시
  ↓ (PostgreSQL 플래너)
수준 5: 데이터베이스
```

### 성능 목표

| 메트릭 | 목표 | 현재 |
|--------|------|------|
| API 응답 시간 | < 200ms (p95) | ~150ms |
| 페이지 로드 시간 (LCP) | < 2.5s | ~1.8s |
| 상호작용까지의 시간 | < 3.5s | ~2.5s |
| 동시 사용자 | 10,000+ | 테스트됨 |
| 데이터베이스 쿼리 시간 | < 50ms (p95) | ~30ms |

---

## 배포 아키텍처

### 환경 전략

```
┌──────────────────────┐
│ 개발 환경            │
│ - 로컬 + Docker      │
│ - 제한 없음           │
│ - 테스팅 OK         │
└──────────────────────┘
           ↓
┌──────────────────────┐
│ 스테이징            │
│ - 프로덕션 유사     │
│ - 제한된 사용자     │
│ - 최종 테스팅      │
└──────────────────────┘
           ↓
┌──────────────────────┐
│ 프로덕션           │
│ - 높은 가용성       │
│ - 모니터링 & 로깅  │
│ - 백업 & 복구      │
└──────────────────────┘
```

### 배포 파이프라인

```
1. 개발자가 GitHub에 코드 푸시
   ↓
2. GitHub Actions 실행:
   - 린팅 & 타입 검사
   - 단위 & 통합 테스트
   - Docker 이미지 빌드
   - 보안 스캔
   ↓
3. 모든 검사를 통과하면:
   - 이미지를 레지스트리에 푸시
   - 배포 매니페스트 생성
   ↓
4. ArgoCD가 변경 감지
   ↓
5. 환경에 자동 배포
   - 스테이징 (자동)
   - 프로덕션 (승인 필요)
   ↓
6. 모니터링 & 경고 활성화
   - Prometheus 메트릭
   - ELK Stack 로깅
   - Sentry 오류 추적
```

### Infrastructure as Code

```
├── terraform/
│   ├── main.tf           # 공급자 설정
│   ├── vpc.tf            # 네트워크 설정
│   ├── rds.tf            # 데이터베이스
│   ├── elasticache.tf    # Redis
│   ├── ecs.tf            # 컨테이너 오케스트레이션
│   ├── variables.tf      # 입력 변수
│   └── outputs.tf        # 출력
│
└── kubernetes/
    ├── base/
    │   ├── api-deployment.yaml
    │   ├── service.yaml
    │   ├── ingress.yaml
    │   └── configmap.yaml
    │
    └── overlays/
        ├── development/
        ├── staging/
        └── production/
```

---

## 기술 스택 참고자료

### 백엔드 스택

```
언어 & 프레임워크
├── Python 3.11+
├── FastAPI (웹 프레임워크)
├── SQLAlchemy (ORM)
├── Pydantic (데이터 검증)
└── asyncio (비동기 런타임)

데이터베이스 & 캐시
├── PostgreSQL 14+ (주 데이터베이스)
├── Redis 7+ (캐싱 & 세션 저장소)
└── Pinecone (AI용 벡터 데이터베이스)

개발
├── Ruff (빠른 린터)
├── mypy (정적 타입 검사)
├── Black (코드 포매터)
├── pytest (테스팅 프레임워크)
└── pre-commit (git 훅)

배포
├── Docker (컨테이너화)
├── Kubernetes (오케스트레이션)
├── Terraform (Infrastructure as code)
└── GitHub Actions (CI/CD)
```

### 프론트엔드 스택

```
언어 & 프레임워크
├── TypeScript 5+
├── React 18+
├── Next.js 15+ (메타 프레임워크)
└── App Router (파일 기반 라우팅)

스타일 & 컴포넌트
├── Tailwind CSS 4 (유틸리티 CSS)
├── shadcn/ui (React 컴포넌트)
└── CSS Modules (컴포넌트 스타일)

상태 관리
├── Zustand (글로벌 상태)
├── TanStack Query v5 (서버 상태)
└── React Hooks (로컬 상태)

개발
├── ESLint (JavaScript 린팅)
├── Prettier (코드 포매팅)
├── Jest (테스팅)
├── Playwright (e2e 테스팅)
└── TypeScript 엄격 모드
```

### 인프라 스택

```
클라우드 공급자
├── AWS (주요)
├── ECS/EKS (컨테이너 서비스)
├── RDS (관리형 PostgreSQL)
├── ElastiCache (관리형 Redis)
├── S3 (파일 저장소)
├── CloudFront (CDN)
└── Route 53 (DNS)

모니터링 & 관찰성
├── Prometheus (메트릭)
├── Grafana (대시보드)
├── ELK Stack (로깅)
├── Jaeger (분산 추적)
├── Sentry (오류 추적)
└── New Relic (APM)

보안
├── AWS Secrets Manager (시크릿)
├── IAM (접근 제어)
├── VPC (네트워크 격리)
├── WAF (웹 애플리케이션 방화벽)
└── SSL/TLS (암호화)
```

---

## 아키텍처 결정 행렬

### 주요 설계 결정

| 결정 | 검토된 옵션 | 선택됨 | 근거 |
|------|-----------|--------|------|
| **모놀리스 vs 마이크로서비스** | 모놀리스, 마이크로서비스, 서버리스 | 모듈식 모놀리스 | 시작하기 쉬움, 마이크로서비스로 진화 가능 |
| **데이터베이스 전략** | 공유, 테넌트별, 하이브리드 | 테넌트별 | 강력한 격리, 더 나은 보안 |
| **인증** | 세션, JWT, OAuth2 | JWT + 새로고침 토큰 | 무상태, API 친화적 |
| **프론트엔드 프레임워크** | React SPA, Next.js, Angular | Next.js | SSR 이점, 내장 최적화 |
| **스타일링** | CSS-in-JS, Tailwind, CSS Modules | Tailwind CSS | 유틸리티 우선, 작은 번들 |
| **상태 관리** | Redux, Zustand, Context | Zustand + TanStack Query | 가볍고 성능적 |
| **API 설계** | RPC, GraphQL, REST | REST with Envelope | 간단하고 널리 이해됨 |

---

## 향후 로드맵

### Phase 1 (2024년 Q4): 기초
- ✅ 핵심 멀티테넌트 아키텍처
- ✅ 기본 권한 시스템
- ✅ 프론트엔드 프레임워크

### Phase 2 (2025년 Q1-Q2): 개선
- [ ] 마이크로서비스 추출 (결제 서비스 먼저)
- [ ] 이벤트 기반 아키텍처 (RabbitMQ/Kafka)
- [ ] 실시간 기능 (WebSocket)
- [ ] 고급 캐싱 (GraphQL 가능)

### Phase 3 (2025년 Q3): 확장
- [ ] 다중 지역 배포
- [ ] 큰 테넌트에 대한 샤딩 전략
- [ ] 고급 AI/ML 기능
- [ ] 모바일 앱 (React Native)

---

**아키텍처는 살아있는 문서입니다. 시스템이 진화하면서 업데이트하세요.**

자세한 구현 가이드는 다음을 참조하세요:
- [API 개발 가이드](../04_api/01_API개발가이드_20241108.md)
- [프론트엔드 개발 가이드](../05_frontend/FRONTEND-DEVELOPMENT-GUIDE.md)
- [데이터베이스 가이드](../03_database/START_HERE.md)
