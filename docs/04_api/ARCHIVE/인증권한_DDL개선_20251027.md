# 인증권한관리 DDL 개선: 역할 계층 명확화 및 다중역할 지원

**날짜**: 2025-10-27 17:53:00 KST
**작성자**: Claude Code
**유형**: 아키텍처 개선 및 기능 구현
**컴포넌트**: Manager DB (idam), Tenant DB (sys)

## 개요

ConexGrow의 다중 테넌트 SaaS 아키텍처에서 인증 및 권한 관리 시스템을 강화하기 위해 3가지 주요 개선사항을 DDL 레벨에서 구현했습니다:

1. **역할 계층 명확화**: Manager DB의 `idam.roles` 테이블의 모호한 `type` 필드를 명확한 `category`와 `level`로 교체
2. **다중역할 지원 강화**: Tenant DB의 `sys.user_roles`에 권한 충돌 해결 정책 연동
3. **권한 충돌 해결 메커니즘**: 새로운 `sys.permission_conflict_resolution` 테이블 추가

이 개선사항들은 사용자가 여러 역할을 동시에 가질 때 권한 충돌을 체계적으로 해결할 수 있는 기반을 제공합니다.

---

## 1. 문제 정의

### 1.1 기존 설계의 문제점

#### 문제 1: idam.roles의 모호한 타입 분류
```sql
-- 변경 전: 모호한 type 필드
type VARCHAR(50) NOT NULL DEFAULT 'TENANT_USER'
-- 가능한 값: ?, 어떤 가치기준인지 명확하지 않음
```

**문제점**:
- `type` 필드가 여러 의미를 혼재 (admin 유형인지? 범위인지? 계층인지?)
- 새로운 역할 추가 시 의도가 모호해짐
- 권한 계층을 직관적으로 판단하기 어려움

#### 문제 2: 다중역할 시나리오에서 권한 충돌 처리 부재
```
시나리오: 사용자가 "프로젝트 관리자"와 "감사자" 역할을 가질 때
- "프로젝트 관리자": 모든 프로젝트 데이터 수정 허용
- "감사자": 특정 필드만 읽기 전용
→ 충돌 해결 규칙이 명확하지 않음
```

**문제점**:
- 권한 병합 규칙이 코드에 하드코딩될 가능성
- 다양한 충돌 해결 전략을 적용할 수 없음
- 사용자별로 다른 전략을 사용할 수 없음

#### 문제 3: 사용자 수준의 권한 충돌 기본값 부재
- 기본 역할은 있지만, 다중역할 시 기본 전략이 없음
- 모든 권한 충돌을 일관되게 처리하기 어려움

---

## 2. 해결 방안

### 2.1 개선 사항 1: 역할 계층 명확화

#### 2.1.1 변경 사항

**파일**: `packages/database/schemas/manager/02_idam/03_roles.sql`

##### 전: 모호한 type 필드
```sql
type VARCHAR(50) NOT NULL DEFAULT 'TENANT_USER'
```

##### 후: 명확한 category + level 필드
```sql
category VARCHAR(50) NOT NULL DEFAULT 'TENANT_USER'  -- 역할의 종류
level INTEGER NOT NULL DEFAULT 100                   -- 권한 계층 (낮을수록 높은 권한)
```

#### 2.1.2 필드 정의

**category**: 역할의 4가지 종류를 명확하게 분류
```sql
CONSTRAINT ck_roles__category CHECK (
    category IN ('MANAGER_ADMIN', 'PLATFORM_SUPPORT', 'TENANT_ADMIN', 'TENANT_USER')
)
```

| 값 | 설명 | 적용범위 | 예시 |
|---|---|---|---|
| `MANAGER_ADMIN` | 플랫폼 최상위 관리자 | GLOBAL | 시스템 관리자, 운영 총괄 |
| `PLATFORM_SUPPORT` | 플랫폼 지원팀 | GLOBAL | 기술 지원팀, 데이터 분석가 |
| `TENANT_ADMIN` | 테넌트 관리자 | GLOBAL, TENANT | 테넌트 회사의 IT 담당자 |
| `TENANT_USER` | 일반 테넌트 사용자 | TENANT | 테넌트 회사의 일반 직원 |

**level**: 권한 계층을 숫자로 표현
```sql
CONSTRAINT ck_roles__level CHECK (level >= 1 AND level <= 200)
```

| 범위 | 설명 | 예시 레벨 |
|---|---|---|
| 1-10 | 최상위 관리자 | 1: MANAGER_ADMIN |
| 11-50 | 플랫폼 지원팀 | 25: PLATFORM_SUPPORT |
| 51-100 | 테넌트 관리자 | 50: TENANT_ADMIN, 75: TENANT_ADMIN (read-only) |
| 101+ | 일반 사용자 | 100: TENANT_USER, 120: TENANT_USER (limited) |

#### 2.1.3 제약조건 강화

```sql
-- category와 scope의 관계를 명확히 정의
CONSTRAINT ck_roles__category_scope CHECK (
    (category = 'MANAGER_ADMIN' AND scope = 'GLOBAL') OR
    (category = 'PLATFORM_SUPPORT' AND scope = 'GLOBAL') OR
    (category = 'TENANT_ADMIN' AND scope IN ('GLOBAL', 'TENANT')) OR
    (category = 'TENANT_USER' AND scope = 'TENANT')
)
```

**효과**:
- MANAGER_ADMIN은 항상 GLOBAL 범위만 가능
- TENANT_USER는 항상 TENANT 범위만 가능
- 잘못된 조합 방지 (데이터 무결성)

#### 2.1.4 인덱스 개선

**변경 전**:
```sql
CREATE INDEX ix_roles__type ON idam.roles (type) WHERE ...
```

**변경 후**:
```sql
-- 카테고리별 조회
CREATE INDEX IF NOT EXISTS ix_roles__category
    ON idam.roles (category)
 WHERE is_deleted = FALSE AND status = 'ACTIVE';

-- 레벨별 조회 (권한 계층)
CREATE INDEX IF NOT EXISTS ix_roles__level
    ON idam.roles (level ASC)
 WHERE is_deleted = FALSE AND status = 'ACTIVE';

-- 복합 인덱스 (카테고리 + 레벨)
CREATE INDEX IF NOT EXISTS ix_roles__category_level
    ON idam.roles (category, level ASC)
 WHERE is_deleted = FALSE AND status = 'ACTIVE';
```

**성능 개선**:
- `category = 'TENANT_ADMIN' AND level <= 75` 쿼리가 빨라짐
- 권한 계층 기반 조회 최적화

#### 2.1.5 코드 예시: 권한 검증 로직

```python
# 변경 전: 모호한 비교
if user_role.type == 'MANAGER_ADMIN':  # 무엇인지 명확하지 않음
    allow_access()

# 변경 후: 명확한 계층 비교
if user_role.category == 'MANAGER_ADMIN' and user_role.level <= 10:
    # 레벨을 통한 세밀한 제어 가능
    allow_admin_features()

# 또는 레벨만으로 비교 (더 유연함)
if user_role.level <= 50:  # 레벨 50 이상의 모든 역할을 관리자로 취급
    allow_admin_features()
```

---

### 2.2 개선 사항 2: 권한 충돌 해결 메커니즘 추가

#### 2.2.1 새로운 테이블: sys.permission_conflict_resolution

**파일**: `packages/database/schemas/tenants/22_sys/16_permission_conflict_resolution.sql`

이 테이블은 사용자가 여러 역할을 가질 때 권한을 어떻게 병합할지 정의합니다.

```sql
CREATE TABLE IF NOT EXISTS sys.permission_conflict_resolution (
    id UUID PRIMARY KEY,
    code VARCHAR(100) NOT NULL UNIQUE,           -- 정책 코드
    name VARCHAR(200) NOT NULL,                  -- 정책명
    description TEXT,                            -- 설명

    -- 충돌 해결 전략
    conflict_strategy VARCHAR(50) NOT NULL,      -- 병합 전략
    merge_rule VARCHAR(50) NOT NULL,             -- 병합 규칙

    -- 다중역할 제어
    max_concurrent_roles INTEGER,                -- 동시 활성 역할 수 제한

    -- 우선순위 기반 전략
    use_role_priority BOOLEAN NOT NULL,          -- 역할 우선순위 사용 여부
    priority_direction VARCHAR(20),              -- ASC(낮은 숫자 우선) / DESC

    -- 예외 처리
    apply_global_rules BOOLEAN NOT NULL,         -- 글로벌 권한 규칙 적용 여부
    apply_to_admins BOOLEAN NOT NULL,            -- 관리자에게도 적용할지 여부

    -- 상태
    is_active BOOLEAN NOT NULL,                  -- 활성 여부
    is_system BOOLEAN NOT NULL,                  -- 시스템 기본 정책 여부 (수정 불가)
    is_deleted BOOLEAN NOT NULL,

    -- 감사 필드
    created_at TIMESTAMP WITH TIME ZONE,
    created_by UUID,
    updated_at TIMESTAMP WITH TIME ZONE,
    updated_by UUID
);
```

#### 2.2.2 충돌 해결 전략 4가지

| 전략 | 병합 규칙 | 사용 사례 | 예시 |
|---|---|---|---|
| **DENY_OVERRIDE** | AND 연산: 하나라도 거부하면 거부 | 보안이 중요한 경우 | 금융, 의료, 보안팀 |
| **ALLOW_UNION** | OR 연산: 하나라도 허용하면 허용 | 협업이 중요한 경우 | 마케팅, 기획팀 |
| **PRIORITY_BASED** | 우선순위가 높은 역할의 권한 사용 | 명확한 계층이 있을 때 | 프로젝트 관리자 > 팀원 |
| **MOST_RESTRICTIVE** | 가장 제한적인 권한만 사용 | 안정성이 중요할 때 | 감사팀, 컴플라이언스 |

##### 예시 설정

**보안 중심 (DENY_OVERRIDE)**:
```sql
INSERT INTO sys.permission_conflict_resolution (
    code, name, description,
    conflict_strategy, merge_rule,
    max_concurrent_roles, use_role_priority, apply_to_admins, is_system
) VALUES (
    'SECURITY_FIRST', '보안 우선 정책',
    '하나의 역할이라도 거부하면 거부. 보안팀, 금융팀 추천.',
    'DENY_OVERRIDE', 'DENY_OVERRIDE',
    3, false, true, true  -- 시스템 기본 정책
);
```

**협업 중심 (ALLOW_UNION)**:
```sql
INSERT INTO sys.permission_conflict_resolution (
    code, name, description,
    conflict_strategy, merge_rule,
    max_concurrent_roles, use_role_priority, apply_to_admins, is_system
) VALUES (
    'COLLABORATION_FIRST', '협업 중심 정책',
    '하나의 역할이라도 허용하면 허용. 마케팅팀, 기획팀 추천.',
    'ALLOW_UNION', 'ALLOW_UNION',
    5, false, false, true
);
```

**우선순위 기반 (PRIORITY_BASED)**:
```sql
INSERT INTO sys.permission_conflict_resolution (
    code, name, description,
    conflict_strategy, merge_rule,
    max_concurrent_roles, use_role_priority, priority_direction, is_system
) VALUES (
    'PRIORITY_BASED', '우선순위 기반 정책',
    '역할 우선순위를 사용하여 권한 결정. 레벨이 낮을수록(높은 권한)',
    'PRIORITY_BASED', 'PRIORITY_BASED',
    10, true, 'ASC', true
);
```

---

### 2.3 개선 사항 3: 사용자-역할 관계 강화

#### 2.3.1 sys.user_roles 테이블 개선

**파일**: `packages/database/schemas/tenants/22_sys/14_user_roles.sql`

역할 할당 시 적용될 권한 충돌 해결 정책을 명시적으로 지정:

```sql
-- 추가된 필드
conflict_resolution_policy_id UUID,  -- 이 역할 할당에 적용될 정책

-- 외래키 추가
CONSTRAINT fk_user_roles__conflict_resolution_policy_id
    FOREIGN KEY (conflict_resolution_policy_id)
    REFERENCES sys.permission_conflict_resolution(id)
    ON DELETE SET NULL

-- 인덱스 추가
CREATE INDEX IF NOT EXISTS ix_user_roles__conflict_resolution_policy_id
    ON sys.user_roles (conflict_resolution_policy_id)
 WHERE conflict_resolution_policy_id IS NOT NULL AND is_active = TRUE;
```

**효과**:
- 각 역할 할당마다 다른 충돌 해결 정책 적용 가능
- 여러 역할을 가진 사용자도 개별적으로 제어 가능

#### 2.3.2 코드 예시: 다중역할 권한 처리

```python
# 사용자의 모든 활성 역할 조회
user_roles = await db.query(UserRole).where(
    (UserRole.user_id == user_id) &
    (UserRole.is_active == True) &
    (UserRole.expires_at.is_(None) | (UserRole.expires_at > datetime.now()))
).all()

# 각 역할의 권한 정책 로드
policies = [
    role.conflict_resolution_policy_id
    for role in user_roles
]

# 사용자의 기본 정책이 있으면 사용, 없으면 첫 번째 역할의 정책 사용
default_policy = user.default_conflict_resolution_policy_id or policies[0]

# 권한 병합 로직
final_permissions = merge_permissions(
    user_roles=user_roles,
    strategy=default_policy.conflict_strategy
)

# 권한 부여 여부 결정
if can_access(final_permissions, requested_action):
    allow_access()
else:
    deny_access()
```

---

### 2.4 사용자 기본 정책 지정

#### 2.4.1 sys.users 테이블 개선

**파일**: `packages/database/schemas/tenants/22_sys/01_users.sql`

사용자 수준에서 기본 권한 충돌 해결 정책 지정:

```sql
-- 추가된 필드
default_conflict_resolution_policy_id UUID,
    -- 다중 역할 사용 시 기본 권한 충돌 해결 정책

-- 외래키 추가
CONSTRAINT fk_users__default_conflict_resolution_policy_id
    FOREIGN KEY (default_conflict_resolution_policy_id)
    REFERENCES sys.permission_conflict_resolution(id)
    ON DELETE SET NULL

-- 인덱스 추가
CREATE INDEX IF NOT EXISTS ix_users__default_conflict_resolution_policy_id
    ON sys.users (default_conflict_resolution_policy_id)
 WHERE default_conflict_resolution_policy_id IS NOT NULL
   AND is_deleted = FALSE;
```

**사용 시나리오**:
- 역할 할당 시 개별 정책이 지정되지 않으면 사용자의 기본 정책 사용
- 부서별로 다른 기본 정책을 설정 가능 (예: 금융팀 > DENY_OVERRIDE, 마케팅팀 > ALLOW_UNION)

---

## 3. 변경된 파일 목록

| # | 파일 경로 | 변경 유형 | 주요 변경사항 |
|---|---|---|---|
| 1 | `packages/database/schemas/manager/02_idam/03_roles.sql` | 수정 | `type` → `category` + `level`로 변경 |
| 2 | `packages/database/schemas/tenants/22_sys/16_permission_conflict_resolution.sql` | 생성 | 새로운 테이블 생성 (4가지 전략 지원) |
| 3 | `packages/database/schemas/tenants/22_sys/14_user_roles.sql` | 수정 | `conflict_resolution_policy_id` 필드 추가 |
| 4 | `packages/database/schemas/tenants/22_sys/01_users.sql` | 수정 | `default_conflict_resolution_policy_id` 필드 추가 |

---

## 4. 마이그레이션 가이드

### 4.1 새로운 테이블 생성 (sys.permission_conflict_resolution)

```bash
# 마이그레이션 파일 생성 및 적용
cd apps/backend-api

# Alembic으로 마이그레이션 생성
alembic revision --autogenerate -m "Add permission_conflict_resolution table"

# 마이그레이션 적용
alembic upgrade head
```

### 4.2 기존 테이블 수정

```sql
-- 1. idam.roles 수정
ALTER TABLE idam.roles
  DROP COLUMN IF EXISTS type,
  ADD COLUMN category VARCHAR(50) NOT NULL DEFAULT 'TENANT_USER',
  ADD COLUMN level INTEGER NOT NULL DEFAULT 100;

-- 2. sys.user_roles 수정
ALTER TABLE sys.user_roles
  ADD COLUMN conflict_resolution_policy_id UUID;

ALTER TABLE sys.user_roles
  ADD CONSTRAINT fk_user_roles__conflict_resolution_policy_id
    FOREIGN KEY (conflict_resolution_policy_id)
    REFERENCES sys.permission_conflict_resolution(id)
    ON DELETE SET NULL;

-- 3. sys.users 수정
ALTER TABLE sys.users
  ADD COLUMN default_conflict_resolution_policy_id UUID;

ALTER TABLE sys.users
  ADD CONSTRAINT fk_users__default_conflict_resolution_policy_id
    FOREIGN KEY (default_conflict_resolution_policy_id)
    REFERENCES sys.permission_conflict_resolution(id)
    ON DELETE SET NULL;
```

### 4.3 기본 정책 초기화

```sql
-- 시스템 기본 정책 4가지 생성
INSERT INTO sys.permission_conflict_resolution (
    code, name, description,
    conflict_strategy, merge_rule,
    max_concurrent_roles, use_role_priority, apply_to_admins, is_system, is_active
) VALUES
    ('DENY_OVERRIDE', '보안 우선 정책', '하나의 역할이 거부하면 거부',
     'DENY_OVERRIDE', 'DENY_OVERRIDE', 3, false, true, true, true),

    ('ALLOW_UNION', '협업 중심 정책', '하나의 역할이 허용하면 허용',
     'ALLOW_UNION', 'ALLOW_UNION', 5, false, false, true, true),

    ('PRIORITY_BASED', '우선순위 기반 정책', '역할 우선순위로 결정',
     'PRIORITY_BASED', 'PRIORITY_BASED', 10, true, 'ASC', true, true),

    ('MOST_RESTRICTIVE', '최소 권한 정책', '가장 제한적인 권한만 사용',
     'MOST_RESTRICTIVE', 'MOST_RESTRICTIVE', NULL, false, true, true, true);

-- 기본 정책 ID 조회 (예시)
SELECT id FROM sys.permission_conflict_resolution
WHERE code = 'DENY_OVERRIDE' AND is_system = true;
```

---

## 5. 아키텍처 다이어그램

### 5.1 역할 계층 구조

```
┌─────────────────────────────────────────────────────────┐
│                    idam.roles (Manager DB)              │
├─────────────────────────────────────────────────────────┤
│ category        │ level │ scope   │ 설명                  │
├─────────────────────────────────────────────────────────┤
│ MANAGER_ADMIN   │ 1-10  │ GLOBAL  │ 플랫폼 최상위 관리자  │
│ PLATFORM_SUPPORT│ 11-50 │ GLOBAL  │ 플랫폼 지원팀        │
│ TENANT_ADMIN    │ 51-100│ GLOBAL  │ 테넌트 전역 관리자   │
│                 │ 51-100│ TENANT  │ 테넌트 부분 관리자   │
│ TENANT_USER     │ 101+  │ TENANT  │ 일반 사용자          │
└─────────────────────────────────────────────────────────┘
```

### 5.2 권한 충돌 해결 흐름

```
사용자가 여러 역할 보유
    ↓
sys.user_roles 조회
(각 역할의 conflict_resolution_policy_id 확인)
    ↓
사용자의 기본 정책 확인
(sys.users.default_conflict_resolution_policy_id)
    ↓
권한 병합 전략 결정
├─ DENY_OVERRIDE: AND 연산 (하나도 거부면 거부)
├─ ALLOW_UNION: OR 연산 (하나만 허용이면 허용)
├─ PRIORITY_BASED: 우선순위 역할 선택
└─ MOST_RESTRICTIVE: 가장 제한적인 권한만 적용
    ↓
최종 권한 결정
```

### 5.3 테이블 관계도

```
Manager DB:
    idam.roles (category, level)
         ↑
         │ (1대多)
         │
    idam.user_roles

Tenant DB:
    sys.permission_conflict_resolution
         ↑             ↑
         │             │
    (1대多)         (1대多)
         │             │
    sys.user_roles  sys.users
         │             │
         └─────┬───────┘
               │
          sys.users (기본 정책)
```

---

## 6. 코드 예시: 백엔드 구현

### 6.1 권한 검증 미들웨어

```python
# apps/backend-api/src/api/core/permission.py

from enum import Enum
from typing import List, Optional
from sqlalchemy.ext.asyncio import AsyncSession

class ConflictStrategy(str, Enum):
    DENY_OVERRIDE = "DENY_OVERRIDE"
    ALLOW_UNION = "ALLOW_UNION"
    PRIORITY_BASED = "PRIORITY_BASED"
    MOST_RESTRICTIVE = "MOST_RESTRICTIVE"

async def get_user_permissions(
    db: AsyncSession,
    user_id: UUID,
    tenant_id: UUID
) -> dict:
    """사용자의 최종 권한 계산"""

    # 1. 사용자의 모든 활성 역할 조회
    user_roles = await db.query(UserRole).where(
        (UserRole.user_id == user_id) &
        (UserRole.is_active == True)
    ).all()

    if not user_roles:
        return {}

    # 2. 사용자의 기본 정책 조회
    user = await db.query(User).where(User.id == user_id).first()
    default_policy_id = user.default_conflict_resolution_policy_id

    # 3. 정책 로드
    if default_policy_id:
        policy = await db.query(PermissionConflictResolution).where(
            PermissionConflictResolution.id == default_policy_id
        ).first()
    else:
        # 첫 번째 역할의 정책 사용
        first_role_policy_id = user_roles[0].conflict_resolution_policy_id
        policy = await db.query(PermissionConflictResolution).where(
            PermissionConflictResolution.id == first_role_policy_id
        ).first()

    # 4. 각 역할의 권한 수집
    role_permissions = []
    for user_role in user_roles:
        role_perms = await get_role_permissions(db, user_role.role_id)
        role_permissions.append(role_perms)

    # 5. 정책에 따라 권한 병합
    final_permissions = merge_permissions(
        role_permissions,
        policy.conflict_strategy
    )

    return final_permissions

def merge_permissions(
    role_permissions: List[dict],
    strategy: ConflictStrategy
) -> dict:
    """역할 권한 병합"""

    if strategy == ConflictStrategy.DENY_OVERRIDE:
        # AND 연산: 모든 역할이 허용해야 허용
        return {
            action: all(
                perms.get(action, False) for perms in role_permissions
            )
            for action in get_all_actions()
        }

    elif strategy == ConflictStrategy.ALLOW_UNION:
        # OR 연산: 하나의 역할이라도 허용하면 허용
        return {
            action: any(
                perms.get(action, False) for perms in role_permissions
            )
            for action in get_all_actions()
        }

    elif strategy == ConflictStrategy.PRIORITY_BASED:
        # 우선순위가 가장 높은 역할의 권한 사용
        highest_priority = role_permissions[0]
        return highest_priority

    elif strategy == ConflictStrategy.MOST_RESTRICTIVE:
        # 모든 액션에서 가장 제한적인 권한 사용
        return {
            action: all(
                perms.get(action, False) for perms in role_permissions
            )
            for action in get_all_actions()
        }

    return {}
```

### 6.2 역할 생성 예시

```python
# apps/backend-api/src/api/services/tenant/role_service.py

async def create_role_with_levels(
    db: AsyncSession,
    role_data: dict
) -> Role:
    """세분화된 레벨을 가진 역할 생성"""

    category = role_data['category']
    level = role_data['level']

    # category와 level의 유효성 검증
    valid_levels = {
        'MANAGER_ADMIN': (1, 10),
        'PLATFORM_SUPPORT': (11, 50),
        'TENANT_ADMIN': (51, 100),
        'TENANT_USER': (101, 200),
    }

    min_level, max_level = valid_levels[category]
    if not (min_level <= level <= max_level):
        raise ValueError(
            f"Invalid level {level} for category {category}. "
            f"Expected {min_level}-{max_level}"
        )

    role = Role(
        code=role_data['code'],
        name=role_data['name'],
        category=category,
        level=level,
        scope=role_data.get('scope', 'TENANT'),
        description=role_data.get('description', '')
    )

    db.add(role)
    await db.commit()

    return role

# 사용 예시
await create_role_with_levels(db, {
    'code': 'finance_manager',
    'name': '재무 관리자',
    'category': 'TENANT_ADMIN',
    'level': 75,  # TENANT_ADMIN 범위 내의 레벨
    'scope': 'TENANT',
    'description': '재무팀 관리자 역할'
})
```

---

## 7. 테스트 시나리오

### 7.1 역할 계층 테스트

```python
# apps/backend-api/tests/integration/test_role_hierarchy.py

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

@pytest.mark.asyncio
async def test_role_category_validation(db: AsyncSession):
    """category와 scope 제약조건 테스트"""

    # MANAGER_ADMIN은 GLOBAL만 가능해야 함
    with pytest.raises(IntegrityError):
        role = Role(
            code='invalid_admin',
            name='Invalid Admin',
            category='MANAGER_ADMIN',
            level=5,
            scope='TENANT'  # 불가능
        )
        db.add(role)
        await db.commit()

@pytest.mark.asyncio
async def test_role_level_range(db: AsyncSession):
    """레벨 범위 검증 테스트"""

    # TENANT_ADMIN 레벨은 51-100 범위
    with pytest.raises(ValueError):
        await create_role_with_levels(db, {
            'code': 'admin_role',
            'name': 'Admin Role',
            'category': 'TENANT_ADMIN',
            'level': 150,  # 범위를 벗어남
        })
```

### 7.2 권한 충돌 해결 테스트

```python
# apps/backend-api/tests/integration/test_permission_conflict.py

@pytest.mark.asyncio
async def test_deny_override_strategy(db: AsyncSession):
    """DENY_OVERRIDE 전략 테스트"""

    # 준비: 사용자에게 두 개의 역할 할당
    # 역할 1: 문서 수정 가능
    # 역할 2: 문서 수정 불가 (감사자)

    policy = await db.query(PermissionConflictResolution).where(
        PermissionConflictResolution.code == 'DENY_OVERRIDE'
    ).first()

    permissions = await get_user_permissions(db, user_id, tenant_id)

    # DENY_OVERRIDE: 하나도 거부하면 거부
    assert permissions['edit_document'] == False

@pytest.mark.asyncio
async def test_allow_union_strategy(db: AsyncSession):
    """ALLOW_UNION 전략 테스트"""

    policy = await db.query(PermissionConflictResolution).where(
        PermissionConflictResolution.code == 'ALLOW_UNION'
    ).first()

    permissions = await get_user_permissions(db, user_id, tenant_id)

    # ALLOW_UNION: 하나라도 허용하면 허용
    assert permissions['view_document'] == True
```

---

## 8. 데이터 마이그레이션 예시

### 8.1 기존 데이터 변환

```sql
-- 8.1.1 idam.roles 데이터 변환
UPDATE idam.roles
SET
    category = CASE
        WHEN type = 'MANAGER_ADMIN' THEN 'MANAGER_ADMIN'
        WHEN type = 'PLATFORM_SUPPORT' THEN 'PLATFORM_SUPPORT'
        WHEN type = 'TENANT_ADMIN' THEN 'TENANT_ADMIN'
        ELSE 'TENANT_USER'
    END,
    level = CASE
        WHEN type = 'MANAGER_ADMIN' THEN 5
        WHEN type = 'PLATFORM_SUPPORT' THEN 25
        WHEN type = 'TENANT_ADMIN' THEN 75
        ELSE 100
    END
WHERE type IS NOT NULL;

-- 8.1.2 sys.user_roles에 기본 정책 설정
UPDATE sys.user_roles ur
SET conflict_resolution_policy_id = (
    SELECT id FROM sys.permission_conflict_resolution
    WHERE code = 'DENY_OVERRIDE' AND is_system = true
    LIMIT 1
)
WHERE conflict_resolution_policy_id IS NULL;

-- 8.1.3 sys.users에 기본 정책 설정
UPDATE sys.users u
SET default_conflict_resolution_policy_id = (
    SELECT id FROM sys.permission_conflict_resolution
    WHERE code = 'DENY_OVERRIDE' AND is_system = true
    LIMIT 1
)
WHERE default_conflict_resolution_policy_id IS NULL;
```

---

## 9. 성능 고려사항

### 9.1 인덱스 전략

생성된 인덱스들이 다음 쿼리 패턴을 최적화합니다:

```sql
-- 패턴 1: 카테고리별 역할 조회 (ix_roles__category)
SELECT * FROM idam.roles
WHERE category = 'TENANT_ADMIN' AND is_deleted = FALSE;

-- 패턴 2: 레벨별 역할 조회 (ix_roles__level)
SELECT * FROM idam.roles
WHERE level <= 50 AND is_deleted = FALSE;

-- 패턴 3: 사용자의 정책별 역할 조회 (ix_user_roles__conflict_resolution_policy_id)
SELECT * FROM sys.user_roles
WHERE user_id = $1 AND conflict_resolution_policy_id = $2;

-- 패턴 4: 활성 정책 조회 (ix_permission_conflict_resolution__is_active)
SELECT * FROM sys.permission_conflict_resolution
WHERE is_active = TRUE AND is_deleted = FALSE;
```

### 9.2 쿼리 최적화 팁

```python
# ❌ 비효율적: N+1 쿼리
for user in users:
    roles = await db.query(Role).where(Role.id.in_(user.role_ids)).all()
    # 반복마다 쿼리 실행

# ✅ 효율적: 배치 조회
role_ids = [r for user in users for r in user.role_ids]
roles = await db.query(Role).where(Role.id.in_(role_ids)).all()
# 한 번의 쿼리로 모든 역할 조회

# ✅ 효율적: 조인 사용
users_with_roles = await db.query(User).options(
    selectinload(User.roles)
).all()
```

---

## 10. 모니터링 및 감사

### 10.1 권한 변경 추적

```sql
-- sys.user_roles의 감사 필드
SELECT
    ur.id,
    ur.user_id,
    ur.role_id,
    ur.granted_at,
    ur.granted_by,
    ur.conflict_resolution_policy_id,
    urb.username as granted_by_name
FROM sys.user_roles ur
LEFT JOIN sys.users urb ON ur.granted_by = urb.id
WHERE ur.user_id = $1
ORDER BY ur.granted_at DESC;
```

### 10.2 정책 사용 통계

```sql
-- 가장 자주 사용되는 권한 충돌 정책
SELECT
    pcr.code,
    pcr.name,
    COUNT(ur.id) as usage_count
FROM sys.permission_conflict_resolution pcr
LEFT JOIN sys.user_roles ur ON pcr.id = ur.conflict_resolution_policy_id
GROUP BY pcr.id, pcr.code, pcr.name
ORDER BY usage_count DESC;
```

---

## 11. 향후 개선사항

### 11.1 단기 (3개월)
- [ ] 권한 충돌 해결 로직 백엔드 구현 완료
- [ ] 역할 계층 기반 권한 검증 API 통합
- [ ] 관리자 UI에서 권한 정책 관리 기능

### 11.2 중기 (6개월)
- [ ] 시간 기반 권한 자동 전환 (예: 저녁 6시 이후 제한된 권한)
- [ ] 머신러닝 기반 비정상 권한 사용 감지
- [ ] 권한 사용 분석 대시보드

### 11.3 장기 (12개월)
- [ ] 속성 기반 접근 제어 (ABAC) 통합
- [ ] 동적 권한 추가 및 감소 자동화
- [ ] 글로벌 규정 준수 (GDPR, CCPA) 기능

---

## 12. 참고 문서

### 관련 문서
- [인증권한관리_아키텍처분석_20251027170500.md](./인증권한관리_아키텍처분석_20251027170500.md) - 아키텍처 분석 및 개선사항 도출
- [DDL_애플리케이션코드_마이그레이션_20251027162600.md](./DDL_애플리케이션코드_마이그레이션_20251027162600.md) - 초기 컬럼 표준화 작업
- [컬럼명표준화_추가변경_20251027170000.md](./컬럼명표준화_추가변경_20251027170000.md) - 추가 컬럼 표준화

### 외부 참고
- [OWASP - Role Based Access Control](https://owasp.org/www-community/attacks/Privilege_escalation)
- [PostgreSQL Foreign Keys](https://www.postgresql.org/docs/current/ddl-constraints.html#DDL-CONSTRAINTS-FK)
- [SQLAlchemy ORM Documentation](https://docs.sqlalchemy.org/en/20/)

---

## 13. 체크리스트

마이그레이션 실행 시 확인사항:

- [ ] Alembic 마이그레이션 파일 생성 및 테스트
- [ ] 데이터 백업 완료
- [ ] 개발 환경에서 마이그레이션 테스트
- [ ] 기본 정책 4가지 초기화 확인
- [ ] 기존 데이터 변환 쿼리 검증
- [ ] 스테이징 환경 마이그레이션
- [ ] 관리자 UI 업데이트
- [ ] API 엔드포인트 업데이트
- [ ] 백엔드 로직 구현
- [ ] 전체 통합 테스트 실행
- [ ] 프로덕션 배포 전 모의 실습(dry-run)
- [ ] 운영팀 교육 및 문서 배포

---

**생성일**: 2025-10-27 17:53:00 KST
**최종 수정**: 2025-10-27 17:53:00 KST
**버전**: 1.0
