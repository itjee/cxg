# 로그인 엔드포인트 signin 변경 및 bcrypt 이슈 해결

**날짜**: 2025-10-20 22:59:23 KST
**작성자**: Claude Code
**유형**: 기능 개선 | 버그 수정
**컴포넌트**: Backend API - Auth Module

## 개요
로그인 API 엔드포인트를 `/login`에서 `/signin`으로 변경하고, bcrypt 5.x 버전의 strict password length checking 이슈를 해결했습니다. 또한 CORS 설정이 이미 올바르게 구성되어 있음을 확인했습니다.

## 식별된 문제점

### 1. 엔드포인트 명명 일관성
- 기존 `/login` 엔드포인트를 더 직관적인 `/signin`으로 변경 필요
- 회원가입은 `/signup`으로 되어 있어 일관성을 위해 로그인도 `/signin`으로 변경

### 2. bcrypt 5.x 버전 호환성 이슈
- bcrypt 5.0.0에서 strict password length checking이 기본으로 활성화됨
- "password cannot be longer than 72 bytes" 에러가 발생
- 8바이트 길이의 간단한 비밀번호("Test1234")에서도 에러 발생
- passlib과 bcrypt 5.x 간의 호환성 문제

## 변경 내용

### 1. Backend 엔드포인트 변경

#### `src/modules/manager/auth/router.py`
```python
# 변경 전
@router.post("/login", ...)
async def login(data: LoginRequest, ...) -> EnvelopeResponse[TokenResponse]:
    ...

# 변경 후
@router.post("/signin", ...)
async def signin(data: LoginRequest, ...) -> EnvelopeResponse[TokenResponse]:
    ...
```

#### `src/main.py`
```python
# API 문서 업데이트
### 인증
대부분의 API는 Bearer 토큰 인증이 필요합니다.
1. `/api/v1/manager/auth/signin`으로 로그인  # /login에서 변경
2. 응답에서 `access_token` 획득
3. 헤더에 `Authorization: Bearer {access_token}` 추가
```

### 2. Frontend API 클라이언트 업데이트

#### `apps/manager-web/src/lib/api/auth.ts`
```typescript
// 변경 전
export async function login(data: LoginRequest): Promise<TokenResponse> {
  const response = await apiClient.post<ApiResponse<TokenResponse>>("/manager/auth/login", data);
  return response.data.data;
}

// 변경 후
export async function signin(data: LoginRequest): Promise<TokenResponse> {
  const response = await apiClient.post<ApiResponse<TokenResponse>>("/manager/auth/signin", data);
  return response.data.data;
}
```

#### `apps/manager-web/src/stores/auth.store.ts`
```typescript
// authApi.login 호출을 authApi.signin으로 변경
const tokenData = await authApi.signin({ username, password });
```

### 3. bcrypt 버전 고정

#### `apps/backend-api/pyproject.toml`
```toml
dependencies = [
    ...
    "passlib[bcrypt]>=1.7.4",
    "bcrypt>=4.0.0,<5.0.0",  # Pin to 4.x (5.x has strict password length checking)
    ...
]
```

#### `src/core/security.py`
```python
def _truncate_password(password: str) -> bytes:
    """비밀번호를 bcrypt 제한(72바이트)에 맞게 자르기"""
    password_bytes = password.encode('utf-8')
    if len(password_bytes) > 72:
        return password_bytes[:72]
    return password_bytes

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """비밀번호 검증"""
    password_bytes = _truncate_password(plain_password)
    return pwd_context.verify(password_bytes, hashed_password)

def get_password_hash(password: str) -> str:
    """비밀번호 해싱"""
    password_bytes = _truncate_password(password)
    return pwd_context.hash(password_bytes)
```

## 변경된 파일 목록

### Backend
- `apps/backend-api/src/modules/manager/auth/router.py`
- `apps/backend-api/src/main.py`
- `apps/backend-api/src/core/security.py`
- `apps/backend-api/pyproject.toml`

### Frontend
- `apps/manager-web/src/lib/api/auth.ts`
- `apps/manager-web/src/stores/auth.store.ts`

## 테스트

### 1. 회원가입 테스트
```bash
curl -s 'http://localhost:8100/api/v1/manager/auth/signup' \
  -H 'Content-Type: application/json' \
  -d '{"username":"user002","email":"user002@test.com","password":"Test1234","full_name":"User 002"}'

# 응답
{
  "success": true,
  "data": {
    "id": "8c88c1c2-0a4f-4d7c-a347-b8d6254c9a28",
    "username": "user002",
    "email": "user002@test.com",
    "full_name": "User 002",
    "user_type": "MASTER",
    "status": "ACTIVE",
    "created_at": "2025-10-20T04:55:41.502669Z"
  },
  "error": null
}
```

### 2. 로그인 (signin) 테스트
```bash
curl -s 'http://localhost:8100/api/v1/manager/auth/signin' \
  -H 'Content-Type: application/json' \
  -d '{"username":"user002","password":"Test1234"}'

# 응답
{
  "success": true,
  "data": {
    "access_token": "eyJhbGci...",
    "refresh_token": "eyJhbGci...",
    "token_type": "bearer",
    "expires_in": 900
  },
  "error": null
}
```

### 3. Frontend 테스트
1. 브라우저에서 `http://localhost:8200/signin` 접속
2. 테스트 계정으로 로그인 시도
3. CORS 에러 없이 정상 로그인 확인
4. 토큰 발급 및 대시보드 리다이렉트 확인

## 기술적 배경

### bcrypt 72바이트 제한
- bcrypt 알고리즘은 최대 72바이트의 비밀번호만 처리 가능
- 이는 bcrypt의 설계 제한사항으로, Blowfish 암호화 알고리즘 특성
- UTF-8 인코딩 시 일부 특수문자는 2-4바이트를 차지할 수 있음

### bcrypt 버전별 차이
- **bcrypt 4.x**: 72바이트 초과 시 자동으로 truncate하거나 경고 없이 처리
- **bcrypt 5.x**: 72바이트 초과 시 명시적 에러 발생 (strict mode)
- passlib 1.7.4는 bcrypt 5.x의 strict mode를 지원하지 않음

### 선택한 해결방안
1. bcrypt를 4.x로 고정 (안정성 우선)
2. 비밀번호를 bytes로 변환하여 전달
3. 명시적인 truncation 함수 구현

## CORS 설정 확인

### 현재 CORS 설정 (`src/core/config.py`)
```python
allowed_origins: list[str] = [
    "http://localhost:8200",  # manager-web
    "http://localhost:8300",  # tenants-web
]
```

### middleware 설정 (`src/main.py`)
```python
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.allowed_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)
```

CORS 설정은 이미 올바르게 구성되어 있어 추가 변경 불필요.

## 향후 개선사항

### 1. 비밀번호 보안 강화
- 비밀번호 복잡도 검증 추가 (대소문자, 숫자, 특수문자 조합)
- 비밀번호 재사용 방지 (이전 비밀번호 히스토리 저장)
- 비밀번호 만료 정책 구현

### 2. bcrypt 5.x 마이그레이션 준비
- passlib의 bcrypt 5.x 지원 업데이트 모니터링
- 또는 bcrypt 직접 사용으로 전환 고려

### 3. 인증 강화
- 2FA (Two-Factor Authentication) 구현
- 로그인 시도 제한 (rate limiting)
- 의심스러운 로그인 감지 및 알림

## 참고사항

### API 엔드포인트 변경 영향
- 기존 `/login` 엔드포인트를 사용하던 클라이언트는 `/signin`으로 업데이트 필요
- API 문서 (Swagger/ReDoc)도 자동으로 업데이트됨
- 하위 호환성 필요 시 `/login` 엔드포인트를 `/signin`의 alias로 유지 가능

### bcrypt 버전 고정의 의미
- 프로덕션 환경에서 예기치 않은 동작 방지
- 의존성 업데이트 시 명시적인 검토 필요
- `pip install -U` 실행 시 bcrypt는 4.x 범위 내에서만 업데이트됨

### 비밀번호 길이 제한
- 프론트엔드 validation에 72바이트 체크 추가 권장
- 대부분의 실용적인 비밀번호는 72바이트 미만
- 예: 영문 72자, 한글 24자, 특수문자 혼합 시 약 40-50자
