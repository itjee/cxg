# 사용자/권한 관리 아키텍처 결정

**날짜**: 2025-01-26 12:57:58 KST  
**작성자**: Claude AI  
**유형**: 아키텍처 결정  
**컴포넌트**: Manager DB (idam), Tenant DB (sys)

## 질문

사용자와 권한, 역할을 Manager DB(운영자)에서 관리할지, 각 Tenant DB에서 개별로 관리할지?

## 결정: Tenant DB에서 개별 관리 ⭐

### 현재 문제

두 DB에 중복된 구조가 존재:
- **Manager DB (idam)**: `users`, `roles`, `permissions`, `role_permissions`, `user_roles`
- **Tenant DB (sys)**: `users`, `roles`, `permissions`, `role_permissions`

## 아키텍처 결정

### 최종 구조

```
Manager DB (mgmt_db):
├── idam.users           → 플랫폼 운영자만 (MASTER 타입)
├── idam.roles           → 운영자 역할만
├── idam.permissions     → 운영자 권한만
├── idam.role_permissions
├── idam.user_roles
└── tnnt.tenants         → 테넌트 메타데이터

Tenant DB (tnnt_db):
├── sys.users            → 테넌트 사용자 (각 테넌트별)
├── sys.roles            → 테넌트 역할
├── sys.permissions      → 테넌트 권한 (modules FK 포함)
├── sys.role_permissions
├── sys.modules          → 모듈 마스터
└── sys.tenant_modules   → 모듈 구독
```

### 역할 분리

#### Manager DB: 플랫폼 운영
- **대상**: ConexGrow 플랫폼 운영진
- **역할**: SUPER_ADMIN, TENANT_MANAGER, SUPPORT, AUDITOR
- **권한**: 테넌트 관리, 빌링, 시스템 모니터링
- **접근**: manager-web 앱

#### Tenant DB: 비즈니스 운영
- **대상**: 각 테넌트 기업의 직원
- **역할**: ADMIN, MANAGER, USER, GUEST (테넌트별 커스터마이징)
- **권한**: 모듈별 CRUD, 승인, 보고서 등
- **접근**: tenants-web 앱

## 선택 이유

### 1. 확장성 ✅
- **병목 회피**: 사용자 증가 시 Manager DB에 부하 집중 방지
- **수평 확장**: 테넌트별 DB 샤딩 가능
- **대기업 대응**: 테넌트당 수백~수천명 사용자도 대응

예시:
```
테넌트 100개 × 평균 50명 = 5,000명
→ Manager DB 중앙관리: 5,000명 전부 한 곳
→ Tenant DB 개별관리: 50명씩 100개 DB에 분산
```

### 2. 현대 SaaS 표준 ✅
검증된 패턴:
- **Salesforce**: Organization별 독립 사용자
- **Slack**: Workspace별 독립 사용자
- **Microsoft 365**: Tenant별 독립 사용자
- **Atlassian Cloud**: Site별 독립 사용자

### 3. 데이터 격리 & 보안 ✅
- **물리적 격리**: 테넌트 A의 사용자 데이터가 테넌트 B와 완전 분리
- **규정 준수**: GDPR, 개인정보보호법 대응
- **감사 추적**: 테넌트별 독립 감사 로그
- **데이터 주권**: 엔터프라이즈 요구사항 (리전별 DB)

### 4. 테넌트 독립성 ✅
- **커스터마이징**: 테넌트별 권한 모델 조정 가능
- **장애 격리**: 한 테넌트 문제가 다른 테넌트 영향 없음
- **성능**: 네트워크 홉 감소 (Tenant DB 내에서 완결)

### 5. 비즈니스 모델 ✅
- **B2B SaaS**: 각 기업(테넌트)이 독립 운영
- **모듈 구독**: 테넌트별 다른 권한 필요
- **엔터프라이즈 판매**: 독립성이 판매 포인트

## 구현 가이드

### Phase 1: 역할 명확화 (즉시)

#### Manager DB 수정
```sql
-- idam.users: TENANT 타입 제거, MASTER만
ALTER TABLE idam.users
DROP CONSTRAINT IF EXISTS ck_users__user_type;

ALTER TABLE idam.users
ADD CONSTRAINT ck_users__user_type 
CHECK (user_type = 'MASTER');  -- TENANT, SYSTEM 제거

COMMENT ON TABLE idam.users IS '플랫폼 운영자 계정 (ConexGrow 관리자만)';
COMMENT ON COLUMN idam.users.user_type IS 'MASTER만 허용 (플랫폼 운영자)';
```

#### Tenant DB 수정
```sql
-- sys.users: tenant_id 필수화
ALTER TABLE sys.users
ALTER COLUMN tenant_id SET NOT NULL;

-- 유니크 제약 추가 (테넌트별 username, email 유니크)
CREATE UNIQUE INDEX IF NOT EXISTS ux_users__tenant_username
ON sys.users (tenant_id, username)
WHERE is_deleted = false;

CREATE UNIQUE INDEX IF NOT EXISTS ux_users__tenant_email
ON sys.users (tenant_id, email)
WHERE is_deleted = false;

COMMENT ON TABLE sys.users IS '테넌트 사용자 계정 (각 기업의 직원)';
```

### Phase 2: 인증 플로우 분리

#### 1. Tenant 사용자 로그인
```python
# apps/backend-api/src/api/routers/auth/tenant_login.py

@router.post("/auth/tenant/login")
async def tenant_login(
    credentials: TenantLoginSchema,
    tenant_subdomain: str = Header(..., alias="X-Tenant-Subdomain")
):
    # 1. 서브도메인으로 tenant_id 조회 (캐싱 추천)
    tenant = await get_tenant_by_subdomain(tenant_subdomain)
    
    # 2. Tenant DB 연결
    tenant_db = get_tenant_database(tenant.id)
    
    # 3. 사용자 인증
    user = await authenticate_user(
        tenant_db,
        credentials.username,
        credentials.password
    )
    
    # 4. JWT 발급
    token = create_access_token({
        "user_id": str(user.id),
        "tenant_id": str(tenant.id),
        "user_type": "TENANT",
        "permissions": await get_user_permissions(user)
    })
    
    return {"access_token": token, "token_type": "bearer"}
```

#### 2. Manager 운영자 로그인
```python
# apps/backend-api/src/api/routers/auth/admin_login.py

@router.post("/auth/admin/login")
async def admin_login(credentials: AdminLoginSchema):
    # 1. Manager DB 연결
    mgmt_db = get_manager_database()
    
    # 2. 운영자 인증
    admin = await authenticate_admin(
        mgmt_db,
        credentials.username,
        credentials.password
    )
    
    # 3. JWT 발급
    token = create_access_token({
        "user_id": str(admin.id),
        "user_type": "MASTER",
        "admin_role": admin.role,
        "permissions": await get_admin_permissions(admin)
    })
    
    return {"access_token": token, "token_type": "bearer"}
```

### Phase 3: API 라우팅

```python
# 미들웨어에서 토큰 검증 및 DB 라우팅
def get_database_from_token(token: str):
    payload = decode_jwt(token)
    
    if payload["user_type"] == "MASTER":
        return get_manager_database()
    elif payload["user_type"] == "TENANT":
        return get_tenant_database(payload["tenant_id"])
    else:
        raise AuthenticationError("Invalid user type")
```

## 데이터베이스 역할 정리

### Manager DB (mgmt_db)

| 테이블 | 목적 | 데이터 예시 |
|--------|------|------------|
| `idam.users` | 플랫폼 운영자 | admin@conexgrow.com |
| `idam.roles` | 운영자 역할 | SUPER_ADMIN, SUPPORT |
| `idam.permissions` | 운영자 권한 | TENANT_CREATE, BILLING_VIEW |
| `tnnt.tenants` | 테넌트 메타 | company_a (subdomain: companya) |

### Tenant DB (tnnt_db)

| 테이블 | 목적 | 데이터 예시 |
|--------|------|------------|
| `sys.users` | 비즈니스 사용자 | john@companya.com (tenant_id 포함) |
| `sys.roles` | 비즈니스 역할 | ADMIN, SALES_MANAGER, ACCOUNTANT |
| `sys.permissions` | 비즈니스 권한 | PSM_ORDERS_CREATE, SRM_INVOICE_APPROVE |
| `sys.modules` | 모듈 정의 | PSM, SRM, IVM |

## 장단점 비교

### 장점 ✅

1. **확장성**: 테넌트 증가해도 Manager DB 부하 없음
2. **성능**: 로그인/권한 체크가 Tenant DB 내에서 완결
3. **격리**: 테넌트 간 완전한 데이터 격리
4. **독립성**: 테넌트별 권한 모델 커스터마이징
5. **장애 격리**: 한 테넌트 장애가 다른 테넌트 영향 없음
6. **엔터프라이즈**: 데이터 주권, 규정 준수 용이

### 고려사항 ⚠️

1. **복잡성**: 각 테넌트마다 사용자 관리 필요
2. **크로스 테넌트**: 전체 사용자 통계는 집계 필요
3. **중앙 감사**: 로그 통합 시스템 필요

→ **해결**: 로그 수집 파이프라인 (Fluent Bit → Elasticsearch)

## 실제 사례

### Salesforce
```
Organization A:
├── 사용자: john@companya.com
└── 권한: Sales Manager, View All Accounts

Organization B:
├── 사용자: jane@companyb.com
└── 권한: System Admin, Manage Users
```

→ 완전히 독립된 데이터베이스, 크로스 조회 불가

### Slack
```
Workspace "Company A":
├── 사용자: john@companya.com
├── 역할: Workspace Admin
└── 채널: #general, #sales

Workspace "Company B":
├── 사용자: jane@companyb.com
├── 역할: Member
└── 채널: #random, #marketing
```

→ 워크스페이스 간 사용자 공유 없음

## 마이그레이션 체크리스트

### 즉시 실행
- [ ] Manager DB `idam.users`에서 `user_type` 제약 수정 (MASTER만)
- [ ] Tenant DB `sys.users`에 `tenant_id` NOT NULL 제약
- [ ] Tenant DB `sys.users`에 유니크 인덱스 추가 (tenant_id, username)
- [ ] 각 테이블에 명확한 주석 추가

### 단기 (1~2주)
- [ ] 인증 플로우 분리 (tenant_login, admin_login)
- [ ] JWT 페이로드에 user_type 포함
- [ ] API 미들웨어에서 DB 라우팅 로직 추가

### 중기 (1~2개월)
- [ ] 프론트엔드 로그인 페이지 분리
  - `manager.conexgrow.com/login` → Manager 로그인
  - `{tenant}.conexgrow.com/login` → Tenant 로그인
- [ ] 권한 체크 로직 DB별 분리
- [ ] 로그 통합 시스템 구축

### 장기 (3~6개월)
- [ ] 리전별 Tenant DB 분산 (글로벌 확장)
- [ ] 테넌트별 독립 백업/복원
- [ ] 엔터프라이즈 고객 전용 DB 인스턴스

## 성능 비교

### Manager DB 중앙관리 (옵션 1)
```
로그인 요청 → Manager DB 조회 (1 hop)
권한 체크 → Manager DB 조회 (1 hop)
업무 데이터 조회 → Tenant DB 조회 (1 hop)
총 3 hops, Manager DB에 부하 집중
```

### Tenant DB 개별관리 (선택) ⭐
```
로그인 요청 → Tenant DB 조회 (1 hop)
권한 체크 → Tenant DB 조회 (0 hop, 이미 연결됨)
업무 데이터 조회 → Tenant DB 조회 (0 hop, 같은 DB)
총 1 hop, 부하 분산
```

## 보안 고려사항

### 데이터 격리
- ✅ **물리적 격리**: 테넌트 간 SQL Injection으로도 접근 불가
- ✅ **백업 분리**: 테넌트별 독립 백업
- ✅ **암호화**: 테넌트별 다른 암호화 키 사용 가능

### 감사 추적
```sql
-- Tenant DB에서 사용자 활동 로깅
CREATE TABLE sys.audit_logs (
    id UUID PRIMARY KEY,
    tenant_id UUID NOT NULL,
    user_id UUID NOT NULL,
    action VARCHAR(50),
    resource VARCHAR(100),
    timestamp TIMESTAMP WITH TIME ZONE
);

-- 테넌트별 감사 로그 조회
SELECT * FROM sys.audit_logs
WHERE tenant_id = :tenant_id
ORDER BY timestamp DESC;
```

## 결론

**Tenant DB에서 개별 관리**를 선택합니다.

### 핵심 근거
1. ✅ **Salesforce, Slack 등 검증된 패턴**
2. ✅ **확장성 및 성능 우수**
3. ✅ **엔터프라이즈 고객 요구사항 충족**
4. ✅ **ConexGrow의 B2B SaaS 특성에 적합**

### 다음 단계
1. Manager DB와 Tenant DB 역할 명확화 (즉시)
2. 인증 플로우 분리 구현 (단기)
3. 프론트엔드 로그인 페이지 분리 (중기)

---

**참고 문서**: `/tmp/user_auth_architecture_analysis.md`
