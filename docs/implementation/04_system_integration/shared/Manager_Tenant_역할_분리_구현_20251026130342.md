# Manager-Tenant DB 역할 분리 구현

**날짜**: 2025-01-26 13:03:42 KST  
**작성자**: Claude AI  
**유형**: 아키텍처 구현  
**컴포넌트**: Manager DB (idam), Tenant DB (sys)

## 개요

Manager DB와 Tenant DB의 사용자/권한 관리 역할을 명확히 분리하여 확장성, 보안, 테넌트 독립성을 확보합니다.

## 변경 내용

### 1. Manager DB (mgmt_db) - 플랫폼 운영자 전용

#### 생성된 마이그레이션 파일

**`migration_01_restrict_users_to_master.sql`**
```sql
-- idam.users를 MASTER 타입만 허용
ALTER TABLE idam.users
ADD CONSTRAINT ck_users__user_type 
CHECK (user_type = 'MASTER');

COMMENT ON TABLE idam.users IS 
'ConexGrow 플랫폼 운영자 계정 (관리자 전용)';
```

**`migration_02_update_idam_comments.sql`**
```sql
-- 모든 idam 스키마 테이블 주석 업데이트
COMMENT ON SCHEMA idam IS 
'IDAM: ConexGrow 플랫폼 운영자 전용 인증/인가 스키마.
테넌트 비즈니스 사용자는 Tenant DB의 sys 스키마에서 관리됨.';
```

#### 역할 및 권한

| 테이블 | 목적 | 예시 |
|--------|------|------|
| `idam.users` | 플랫폼 운영자 | admin@conexgrow.com |
| `idam.roles` | 운영자 역할 | SUPER_ADMIN, TENANT_MANAGER, SUPPORT, AUDITOR |
| `idam.permissions` | 플랫폼 권한 | TENANT_CREATE, BILLING_VIEW, SYSTEM_MONITOR |

### 2. Tenant DB (tnnt_db) - 비즈니스 사용자 관리

#### 생성된 마이그레이션 파일

**`10_users_add_tenant_id.sql`**
```sql
-- sys.users에 tenant_id 추가 및 테넌트별 유니크 제약
ALTER TABLE sys.users
ADD COLUMN tenant_id UUID;

CREATE UNIQUE INDEX ux_users__tenant_username
ON sys.users (tenant_id, username)
WHERE is_deleted = false;
```

**`11_roles_add_tenant_id.sql`**
```sql
-- sys.roles에 tenant_id 추가
ALTER TABLE sys.roles
ADD COLUMN tenant_id UUID;

CREATE UNIQUE INDEX ux_roles__tenant_role_code
ON sys.roles (tenant_id, role_code)
WHERE is_deleted = false;
```

**`12_permissions_add_tenant_id.sql`**
```sql
-- sys.permissions에 tenant_id 추가 (NULL 허용)
ALTER TABLE sys.permissions
ADD COLUMN tenant_id UUID;

-- NULL: 시스템 기본 권한
-- NOT NULL: 테넌트 커스텀 권한
```

#### 역할 및 권한

| 테이블 | 목적 | 예시 |
|--------|------|------|
| `sys.users` | 비즈니스 사용자 | john@companya.com (tenant_id 포함) |
| `sys.roles` | 비즈니스 역할 | ADMIN, SALES_MANAGER, ACCOUNTANT |
| `sys.permissions` | 비즈니스 권한 | PSM_ORDER_CREATE, SRM_INVOICE_APPROVE |

## 변경된 파일 목록

```
packages/database/schemas/
├── manager/
│   ├── migration_01_restrict_users_to_master.sql    # NEW
│   └── migration_02_update_idam_comments.sql        # NEW
└── tenants/22_sys/
    ├── 10_users_add_tenant_id.sql                   # NEW
    ├── 11_roles_add_tenant_id.sql                   # NEW
    └── 12_permissions_add_tenant_id.sql             # NEW
```

## 적용 순서

### Phase 1: Manager DB 수정 (즉시)

```bash
# 1. 기존 TENANT 사용자 확인
psql -d mgmt_db -c "SELECT COUNT(*) FROM idam.users WHERE user_type = 'TENANT';"

# 2. TENANT 사용자가 있으면 Tenant DB로 마이그레이션 필요
# (별도 마이그레이션 스크립트 작성)

# 3. MASTER 전용으로 제약 변경
psql -d mgmt_db -f packages/database/schemas/manager/migration_01_restrict_users_to_master.sql

# 4. 주석 업데이트
psql -d mgmt_db -f packages/database/schemas/manager/migration_02_update_idam_comments.sql
```

### Phase 2: Tenant DB 수정

```bash
# 1. tenant_id 컬럼 추가
psql -d tnnt_db -f packages/database/schemas/tenants/22_sys/10_users_add_tenant_id.sql
psql -d tnnt_db -f packages/database/schemas/tenants/22_sys/11_roles_add_tenant_id.sql
psql -d tnnt_db -f packages/database/schemas/tenants/22_sys/12_permissions_add_tenant_id.sql

# 2. 기존 데이터에 tenant_id 설정
psql -d tnnt_db -c "UPDATE sys.users SET tenant_id = :actual_tenant_id WHERE tenant_id IS NULL;"

# 3. tenant_id를 NOT NULL로 변경 (users, roles)
psql -d tnnt_db -c "ALTER TABLE sys.users ALTER COLUMN tenant_id SET NOT NULL;"
psql -d tnnt_db -c "ALTER TABLE sys.roles ALTER COLUMN tenant_id SET NOT NULL;"
```

### Phase 3: 애플리케이션 코드 수정

#### 1. 인증 엔드포인트 분리

**Manager 운영자 로그인**
```python
# apps/backend-api/src/api/routers/auth/admin_login.py

@router.post("/auth/admin/login")
async def admin_login(credentials: AdminLoginSchema):
    # Manager DB 연결
    mgmt_db = get_manager_database()
    
    # 운영자 인증 (idam.users)
    admin = await authenticate_admin(mgmt_db, credentials)
    
    # JWT 발급
    token = create_access_token({
        "user_id": str(admin.id),
        "user_type": "MASTER",
        "role": admin.role
    })
    return {"access_token": token}
```

**Tenant 사용자 로그인**
```python
# apps/backend-api/src/api/routers/auth/tenant_login.py

@router.post("/auth/tenant/login")
async def tenant_login(
    credentials: TenantLoginSchema,
    tenant_subdomain: str = Header(..., alias="X-Tenant-Subdomain")
):
    # Manager DB에서 tenant 조회
    mgmt_db = get_manager_database()
    tenant = await get_tenant_by_subdomain(mgmt_db, tenant_subdomain)
    
    # Tenant DB 연결
    tenant_db = get_tenant_database(tenant.id)
    
    # 사용자 인증 (sys.users with tenant_id)
    user = await authenticate_user(tenant_db, tenant.id, credentials)
    
    # JWT 발급
    token = create_access_token({
        "user_id": str(user.id),
        "tenant_id": str(tenant.id),
        "user_type": "TENANT"
    })
    return {"access_token": token}
```

#### 2. 미들웨어 수정

```python
# DB 라우팅
def get_database_from_token(token: str):
    payload = decode_jwt(token)
    
    if payload["user_type"] == "MASTER":
        return get_manager_database()
    elif payload["user_type"] == "TENANT":
        return get_tenant_database(payload["tenant_id"])
```

## 데이터 격리 패턴

### Manager DB
```sql
-- 운영자 조회 (전체 테넌트 접근 가능)
SELECT * FROM idam.users WHERE user_type = 'MASTER';

-- 특정 테넌트 관리 (Manager DB의 tnnt.tenants 참조)
SELECT * FROM tnnt.tenants WHERE subdomain = 'companya';
```

### Tenant DB
```sql
-- 테넌트 사용자 조회 (tenant_id로 격리)
SELECT * FROM sys.users 
WHERE tenant_id = :tenant_id 
  AND is_deleted = false;

-- 테넌트 역할 조회
SELECT * FROM sys.roles 
WHERE tenant_id = :tenant_id 
  AND is_active = true;

-- 권한 조회 (시스템 기본 + 테넌트 커스텀)
SELECT * FROM sys.permissions 
WHERE (tenant_id IS NULL OR tenant_id = :tenant_id)
  AND is_active = true;
```

## 보안 강화

### 1. 테넌트 격리 검증

```python
# 모든 Tenant API 요청에서 tenant_id 검증
async def verify_tenant_access(
    user_id: UUID,
    tenant_id: UUID,
    db: AsyncSession
):
    user = await db.get(User, user_id)
    
    if user.tenant_id != tenant_id:
        raise ForbiddenError("Access denied to different tenant")
    
    return user
```

### 2. Row Level Security (RLS) 옵션

PostgreSQL RLS를 사용하여 DB 레벨에서 격리:

```sql
-- Tenant DB에서 RLS 활성화
ALTER TABLE sys.users ENABLE ROW LEVEL SECURITY;

-- 정책: 사용자는 자신의 tenant_id 데이터만 접근
CREATE POLICY tenant_isolation_policy ON sys.users
    USING (tenant_id = current_setting('app.current_tenant_id')::UUID);
```

## 로그 및 감사

### Manager DB
```sql
-- 플랫폼 운영자 활동 로그
CREATE TABLE idam.audit_logs (
    id UUID PRIMARY KEY,
    user_id UUID REFERENCES idam.users(id),
    action VARCHAR(50),
    resource VARCHAR(100),
    target_tenant_id UUID,  -- 어느 테넌트에 대한 작업인지
    timestamp TIMESTAMP WITH TIME ZONE
);
```

### Tenant DB
```sql
-- 테넌트 사용자 활동 로그
CREATE TABLE sys.audit_logs (
    id UUID PRIMARY KEY,
    tenant_id UUID NOT NULL,
    user_id UUID REFERENCES sys.users(id),
    action VARCHAR(50),
    resource VARCHAR(100),
    timestamp TIMESTAMP WITH TIME ZONE
);
```

## 테스트

### 1. Manager DB 제약 테스트

```sql
-- TENANT 타입 삽입 시도 (실패해야 함)
INSERT INTO idam.users (user_type, username, email, password)
VALUES ('TENANT', 'test', 'test@example.com', 'hash');
-- ERROR: new row violates check constraint "ck_users__user_type"

-- MASTER 타입 삽입 (성공)
INSERT INTO idam.users (user_type, username, email, password)
VALUES ('MASTER', 'admin', 'admin@conexgrow.com', 'hash');
-- SUCCESS
```

### 2. Tenant DB 격리 테스트

```sql
-- 테넌트 A 사용자
INSERT INTO sys.users (tenant_id, username, email, password_hash)
VALUES ('tenant-a-uuid', 'john', 'john@companya.com', 'hash');

-- 테넌트 B 사용자 (같은 username 가능)
INSERT INTO sys.users (tenant_id, username, email, password_hash)
VALUES ('tenant-b-uuid', 'john', 'john@companyb.com', 'hash');
-- SUCCESS (tenant_id가 다르므로)

-- 같은 테넌트에 중복 username 시도 (실패)
INSERT INTO sys.users (tenant_id, username, email, password_hash)
VALUES ('tenant-a-uuid', 'john', 'john2@companya.com', 'hash');
-- ERROR: duplicate key violates unique constraint "ux_users__tenant_username"
```

## 마이그레이션 체크리스트

### 즉시 실행
- [x] Manager DB migration 파일 생성
- [x] Tenant DB migration 파일 생성
- [ ] Manager DB에 migration 적용
- [ ] Tenant DB에 migration 적용
- [ ] 기존 데이터에 tenant_id 설정

### 단기 (1~2주)
- [ ] 인증 엔드포인트 분리 구현
- [ ] JWT 페이로드에 user_type 포함
- [ ] DB 라우팅 미들웨어 구현
- [ ] 테넌트 격리 검증 로직 추가

### 중기 (1~2개월)
- [ ] 프론트엔드 로그인 페이지 분리
  - `manager.conexgrow.com/login` → Manager
  - `{subdomain}.conexgrow.com/login` → Tenant
- [ ] SQLAlchemy 모델 업데이트
- [ ] API 엔드포인트 테스트

### 장기 (3~6개월)
- [ ] Row Level Security (RLS) 적용 검토
- [ ] 로그 통합 시스템 구축
- [ ] 크로스 테넌트 분석 대시보드

## 성능 영향

### Before (중앙 집중)
```
테넌트 로그인 → Manager DB 인증 → Tenant DB 작업
3 hops, Manager DB 병목
```

### After (분산)
```
플랫폼 로그인 → Manager DB 인증 (운영자만)
테넌트 로그인 → Tenant DB 인증 (비즈니스 사용자)
1 hop, 부하 분산
```

## 참고 자료

- **아키텍처 결정 문서**: `docs/implementation/shared/사용자_권한_아키텍처_결정_20251026125758.md`
- **패턴 참고**: Salesforce Multi-Tenant Architecture, Slack Workspace Model
- **보안 가이드**: OWASP Multi-Tenancy Cheat Sheet

## 결론

Manager DB와 Tenant DB의 역할을 명확히 분리하여:
- ✅ **확장성**: 테넌트별 독립 확장 가능
- ✅ **보안**: 물리적 데이터 격리
- ✅ **성능**: 부하 분산
- ✅ **유지보수**: 명확한 책임 분리

---

**다음 단계**: Phase 1 마이그레이션 적용 및 인증 플로우 구현
