# API 에러 응답 처리 구조 개선

**날짜**: 2025-10-20 23:14:43 KST
**작성자**: Claude Code
**유형**: 기능 개선
**컴포넌트**: Manager Web - API Client, Auth

## 개요
백엔드 API의 표준 Envelope 응답 구조에 맞춰 프론트엔드의 에러 처리 로직을 개선했습니다. 성공/실패 응답을 일관되게 처리하고, 사용자에게 명확한 에러 메시지를 표시할 수 있도록 구현했습니다.

## 식별된 문제점

### 1. API 응답 구조 불일치
- 백엔드는 표준 Envelope 구조로 응답
- 프론트엔드는 이전 구조를 기대하고 있었음
- 에러 응답 처리가 일관되지 않음

### 백엔드 API 응답 구조
```json
// 성공 응답
{
  "success": true,
  "data": { /* 실제 데이터 */ },
  "error": null
}

// 에러 응답
{
  "success": false,
  "data": null,
  "error": {
    "code": "AUTHENTICATION_REQUIRED",
    "message": "사용자명 또는 비밀번호가 일치하지 않습니다",
    "detail": {}
  }
}
```

### 2. 에러 메시지 추출 실패
- 기존 코드: `err.response?.data?.message` 형태로 접근
- 실제 구조: `err.response?.data?.error?.message`
- 에러 코드와 상세 정보를 활용하지 못함

## 변경 내용

### 1. API 응답 타입 정의 업데이트

#### `apps/manager-web/src/lib/api/auth.ts`

```typescript
// 이전 구조
export interface ApiResponse<T> {
  success: boolean;
  data: T;
  message?: string;
  meta?: {
    page?: number;
    per_page?: number;
    total?: number;
    total_pages?: number;
  };
}

// 새로운 구조 (백엔드와 일치)
export interface ApiError {
  code: string;
  message: string;
  detail: Record<string, any>;
}

export interface ApiResponse<T> {
  success: boolean;
  data: T | null;
  error: ApiError | null;
}
```

### 2. API 함수 에러 처리 개선

#### 로그인 함수 예시
```typescript
export async function signin(data: LoginRequest): Promise<TokenResponse> {
  const response = await apiClient.post<ApiResponse<TokenResponse>>("/manager/auth/signin", data);

  if (!response.data.success || !response.data.data) {
    const error = response.data.error;
    const errorMessage = error?.message || "로그인에 실패했습니다.";

    // 에러 객체에 추가 정보 포함
    const err: any = new Error(errorMessage);
    err.code = error?.code;
    err.detail = error?.detail;
    throw err;
  }

  return response.data.data;
}
```

모든 API 함수에 동일한 패턴 적용:
- `register()` - 회원가입
- `signin()` - 로그인
- `refreshToken()` - 토큰 갱신
- `getCurrentUser()` - 사용자 정보 조회

### 3. API 클라이언트 인터셉터 개선

#### `apps/manager-web/src/lib/api/client.ts`

```typescript
// 응답 인터셉터
apiClient.interceptors.response.use(
  (response) => {
    // 성공 응답이지만 success=false인 경우 에러로 처리
    if (response.data && response.data.success === false) {
      const error = response.data.error;
      const apiError: any = new Error(error?.message || "요청 처리 중 오류가 발생했습니다.");
      apiError.code = error?.code;
      apiError.detail = error?.detail;
      apiError.response = response;
      return Promise.reject(apiError);
    }
    return response;
  },
  async (error: AxiosError) => {
    // 백엔드 에러 응답 구조 확인
    const responseData = error.response?.data as any;
    if (responseData && responseData.error) {
      // 백엔드 에러 구조를 Error 객체에 추가
      const apiError: any = new Error(responseData.error.message || "요청 처리 중 오류가 발생했습니다.");
      apiError.code = responseData.error.code;
      apiError.detail = responseData.error.detail;
      apiError.response = error.response;

      // 401 처리 및 토큰 갱신 로직...

      return Promise.reject(apiError);
    }

    return Promise.reject(error);
  }
);
```

**주요 개선 사항**:
1. HTTP 200 응답이지만 `success: false`인 경우 에러로 처리
2. 에러 응답의 `code`, `message`, `detail` 추출
3. Error 객체에 추가 정보를 첨부하여 throw

### 4. Signin 페이지 에러 처리 개선

#### `apps/manager-web/src/app/(auth)/signin/page.tsx`

```typescript
try {
  await login(formData.username, formData.password);
  router.push("/core/dashboard");
} catch (err: any) {
  console.error("Login error:", err);

  // 에러 메시지 추출 (백엔드 응답 구조에 맞춤)
  let errorMessage = "로그인 중 오류가 발생했습니다. 다시 시도해주세요.";

  if (err.message) {
    // API 클라이언트에서 처리된 에러 메시지
    errorMessage = err.message;
  } else if (err.response?.data?.error?.message) {
    // 백엔드 에러 응답 구조
    errorMessage = err.response.data.error.message;
  }

  // 에러 코드에 따른 추가 처리
  if (err.code === "AUTHENTICATION_REQUIRED") {
    errorMessage = "사용자명 또는 비밀번호가 일치하지 않습니다.";
  } else if (err.code === "VALIDATION_ERROR") {
    errorMessage = "입력하신 정보를 확인해주세요.";
  }

  setError(errorMessage);
} finally {
  setIsLoading(false);
}
```

**개선 사항**:
1. 다중 레벨 에러 메시지 추출 (우선순위 적용)
2. 에러 코드에 따른 사용자 친화적 메시지 변환
3. 폴백 메시지로 안전한 에러 처리

## 변경된 파일 목록

### Frontend
- `apps/manager-web/src/lib/api/auth.ts` - API 타입 및 함수 업데이트
- `apps/manager-web/src/lib/api/client.ts` - 인터셉터 에러 처리 개선
- `apps/manager-web/src/app/(auth)/signin/page.tsx` - 에러 표시 로직 개선

## 에러 코드 및 메시지 매핑

### 백엔드 에러 코드
| 코드 | 의미 | 사용자 메시지 |
|------|------|--------------|
| `AUTHENTICATION_REQUIRED` | 인증 실패 | "사용자명 또는 비밀번호가 일치하지 않습니다" |
| `VALIDATION_ERROR` | 입력 검증 실패 | "입력하신 정보를 확인해주세요" |
| `RESOURCE_ALREADY_EXISTS` | 중복 리소스 | "이미 존재하는 {리소스}입니다" |
| `RESOURCE_NOT_FOUND` | 리소스 없음 | "{리소스}를 찾을 수 없습니다" |
| `INTERNAL_ERROR` | 서버 내부 오류 | "서버 내부 오류가 발생했습니다" |

### 에러 응답 예시

#### 1. 인증 실패
```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "AUTHENTICATION_REQUIRED",
    "message": "사용자명 또는 비밀번호가 일치하지 않습니다",
    "detail": {}
  }
}
```

#### 2. 검증 실패
```json
{
  "success": false,
  "data": null,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "입력 데이터 검증 실패",
    "detail": {
      "errors": [
        {
          "type": "string_too_short",
          "loc": ["body", "username"],
          "msg": "String should have at least 3 characters",
          "input": "ab",
          "ctx": {"min_length": 3}
        },
        {
          "type": "string_too_short",
          "loc": ["body", "password"],
          "msg": "String should have at least 8 characters",
          "input": "123",
          "ctx": {"min_length": 8}
        }
      ]
    }
  }
}
```

## 테스트

### 1. 잘못된 비밀번호 테스트
```bash
curl -s 'http://localhost:8100/api/v1/manager/auth/signin' \
  -H 'Content-Type: application/json' \
  -d '{"username":"user002","password":"wrongpassword"}'

# 응답
{
  "success": false,
  "data": null,
  "error": {
    "code": "AUTHENTICATION_REQUIRED",
    "message": "사용자명 또는 비밀번호가 일치하지 않습니다",
    "detail": {}
  }
}
```

**프론트엔드 처리**:
- 에러 코드 `AUTHENTICATION_REQUIRED` 감지
- 사용자에게 "사용자명 또는 비밀번호가 일치하지 않습니다" 표시

### 2. 입력 검증 실패 테스트
```bash
curl -s 'http://localhost:8100/api/v1/manager/auth/signin' \
  -H 'Content-Type: application/json' \
  -d '{"username":"ab","password":"123"}'

# 응답
{
  "success": false,
  "data": null,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "입력 데이터 검증 실패",
    "detail": {
      "errors": [...]
    }
  }
}
```

**프론트엔드 처리**:
- 에러 코드 `VALIDATION_ERROR` 감지
- 사용자에게 "입력하신 정보를 확인해주세요" 표시

### 3. 정상 로그인 테스트
```bash
curl -s 'http://localhost:8100/api/v1/manager/auth/signin' \
  -H 'Content-Type: application/json' \
  -d '{"username":"user002","password":"Test1234"}'

# 응답
{
  "success": true,
  "data": {
    "access_token": "eyJ...",
    "refresh_token": "eyJ...",
    "token_type": "bearer",
    "expires_in": 900
  },
  "error": null
}
```

**프론트엔드 처리**:
- `success: true` 확인
- `data`에서 토큰 추출
- 대시보드로 리다이렉트

## 에러 처리 흐름

```
사용자 입력
    ↓
API 호출 (auth.ts)
    ↓
API 클라이언트 인터셉터 (client.ts)
    ↓
[성공 응답]
    ├─ success: true → 데이터 반환
    └─ success: false → 에러로 변환
    ↓
[에러 응답]
    ├─ 백엔드 에러 구조 파싱
    ├─ Error 객체 생성 (code, message, detail 포함)
    └─ Promise.reject(error)
    ↓
API 함수에서 catch
    ↓
페이지 컴포넌트에서 처리
    ├─ 에러 코드에 따른 메시지 변환
    └─ 사용자에게 표시
```

## 향후 개선사항

### 1. 에러 메시지 국제화 (i18n)
```typescript
// 에러 코드를 키로 하는 번역 맵
const errorMessages = {
  ko: {
    AUTHENTICATION_REQUIRED: "사용자명 또는 비밀번호가 일치하지 않습니다",
    VALIDATION_ERROR: "입력하신 정보를 확인해주세요",
  },
  en: {
    AUTHENTICATION_REQUIRED: "Username or password is incorrect",
    VALIDATION_ERROR: "Please check your input",
  }
};
```

### 2. 필드별 검증 에러 표시
```typescript
// detail.errors를 파싱하여 각 입력 필드에 에러 표시
if (err.code === "VALIDATION_ERROR" && err.detail?.errors) {
  err.detail.errors.forEach((fieldError: any) => {
    const field = fieldError.loc[fieldError.loc.length - 1];
    setFieldError(field, fieldError.msg);
  });
}
```

### 3. 에러 로깅 및 모니터링
```typescript
// Sentry, LogRocket 등으로 에러 전송
if (err.code && err.code !== "AUTHENTICATION_REQUIRED") {
  Sentry.captureException(err, {
    tags: { error_code: err.code },
    extra: { detail: err.detail }
  });
}
```

### 4. 재시도 로직
```typescript
// 네트워크 오류나 일시적 오류에 대한 자동 재시도
const maxRetries = 3;
for (let i = 0; i < maxRetries; i++) {
  try {
    return await apiCall();
  } catch (err) {
    if (i === maxRetries - 1 || !isRetryableError(err)) {
      throw err;
    }
    await delay(1000 * Math.pow(2, i)); // Exponential backoff
  }
}
```

## 참고사항

### 에러 처리 모범 사례
1. **일관된 구조**: 모든 API 에러를 동일한 구조로 처리
2. **사용자 친화적 메시지**: 기술적 에러를 이해하기 쉬운 메시지로 변환
3. **에러 코드 활용**: 코드 기반으로 조건부 처리 가능
4. **상세 정보 보존**: `detail` 필드에 디버깅 정보 유지
5. **폴백 메시지**: 예상치 못한 에러에도 기본 메시지 제공

### HTTP 상태 코드 vs 에러 코드
- **HTTP 상태 코드**: 네트워크/프로토콜 레벨 정보 (200, 400, 401, 500 등)
- **에러 코드**: 비즈니스 로직 레벨 정보 (`AUTHENTICATION_REQUIRED`, `VALIDATION_ERROR` 등)
- 두 가지를 조합하여 정확한 에러 처리

### 보안 고려사항
- 민감한 정보는 에러 메시지에 포함하지 않음
- 인증 실패 시 사용자명/비밀번호 중 어느 것이 틀렸는지 명시하지 않음
- 서버 내부 오류 시 스택 트레이스를 클라이언트에 노출하지 않음
