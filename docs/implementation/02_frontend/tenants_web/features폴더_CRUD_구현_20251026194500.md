# Tenants-Web Features 폴더 구조 및 CRUD 구현

**날짜**: 2025-10-26 19:45:00 KST
**작성자**: Claude Code
**유형**: 기능 구현 | 아키텍처 설계
**컴포넌트**: tenants-web / Features / CRUD Logic

## 개요

`src/features` 폴더에 스키마/엔티티 기반의 CRUD 로직을 구현했습니다.

이는:
- **계층 분리**: 타입, 서비스, 훅, 컴포넌트의 명확한 책임 분리
- **재사용성**: 엔티티별 로직을 독립적으로 관리 가능
- **확장성**: 새로운 엔티티 추가 시 동일한 패턴 적용
- **테스트 용이성**: 각 계층을 독립적으로 테스트 가능

## 폴더 구조

```
src/features/
├── adm/                          # Administration
│   ├── codes/
│   │   ├── types/                # 타입 정의
│   │   │   └── index.ts
│   │   ├── services/             # API 서비스
│   │   │   └── codesService.ts
│   │   ├── hooks/                # React Query 훅
│   │   │   └── useCodes.ts
│   │   ├── components/           # React 컴포넌트
│   │   │   ├── CodesList.tsx
│   │   │   ├── CodesForm.tsx
│   │   │   └── ...
│   │   └── index.ts              # 공개 API
│   ├── settings/
│   │   └── ... (동일 구조)
│   └── ...
│
├── crm/                          # Customer Relationship Management
│   ├── partners/                 # 거래처
│   │   ├── types/
│   │   │   └── index.ts
│   │   ├── services/
│   │   │   └── partnersService.ts
│   │   ├── hooks/
│   │   │   └── usePartners.ts
│   │   ├── components/
│   │   │   ├── PartnerList.tsx
│   │   │   ├── PartnerForm.tsx
│   │   │   └── ...
│   │   └── index.ts
│   ├── opportunities/            # 영업 기회
│   ├── activities/               # 활동
│   └── ...
│
├── pim/                          # Product Information Management
│   ├── products/
│   ├── categories/
│   └── ...
│
├── ivm/                          # Inventory Management
│   ├── inventory-balances/
│   ├── inventory-movements/
│   └── ...
│
├── psm/                          # Procurement/Purchase Management
│   ├── purchase-orders/
│   ├── purchase-quotations/
│   └── ...
│
└── ... (다른 스키마들)
```

## 계층별 구현

### 1. Types 계층

**파일**: `features/[schema]/[entity]/types/index.ts`

**목적**: 엔티티의 데이터 구조 정의

**예시**:
```typescript
// features/sys/users/types/index.ts

export interface User {
  id: string;
  name: string;
  email: string;
  phone?: string;
  active: boolean;
  roleIds: string[];
  createdAt: string;
  updatedAt: string;
}

export interface CreateUserRequest {
  name: string;
  email: string;
  phone?: string;
  roleIds: string[];
}

export interface UpdateUserRequest {
  name?: string;
  email?: string;
  phone?: string;
  active?: boolean;
  roleIds?: string[];
}

export interface UserListResponse {
  data: User[];
  total: number;
  page: number;
  pageSize: number;
}

export type UserQueryParams = {
  page?: number;
  pageSize?: number;
  search?: string;
  active?: boolean;
  roleId?: string;
};
```

### 2. Services 계층

**파일**: `features/[schema]/[entity]/services/[entity]Service.ts`

**목적**: API 호출 로직 캡슐화

**특징**:
- Axios를 사용한 HTTP 요청
- 일관된 에러 처리
- 타입 안정성 (TypeScript)

**예시**:
```typescript
// features/crm/partners/services/partnersService.ts

import axios from 'axios';
import type { Partner, CreatePartnerRequest, UpdatePartnerRequest } from '../types';

const API_ENDPOINT = `${API_BASE_URL}/api/03_crm/partners`;

export const partnerService = {
  async list(params?: PartnerQueryParams): Promise<PartnerListResponse> {
    const response = await axios.get<PartnerListResponse>(API_ENDPOINT, {
      params: {
        page: params?.page || 1,
        pageSize: params?.pageSize || 10,
        search: params?.search,
        type: params?.type,
      },
    });
    return response.data;
  },

  async get(id: string): Promise<Partner> {
    const response = await axios.get<Partner>(`${API_ENDPOINT}/${id}`);
    return response.data;
  },

  async create(data: CreatePartnerRequest): Promise<Partner> {
    const response = await axios.post<Partner>(API_ENDPOINT, data);
    return response.data;
  },

  async update(id: string, data: UpdatePartnerRequest): Promise<Partner> {
    const response = await axios.patch<Partner>(`${API_ENDPOINT}/${id}`, data);
    return response.data;
  },

  async delete(id: string): Promise<void> {
    await axios.delete(`${API_ENDPOINT}/${id}`);
  },
};
```

### 3. Hooks 계층

**파일**: `features/[schema]/[entity]/hooks/use[Entity].ts`

**목적**: TanStack Query를 사용한 데이터 페칭 및 캐싱

**특징**:
- 자동 캐싱 및 무효화
- 로딩/에러 상태 관리
- Optimistic Updates 지원
- 자동 리페치

**예시**:
```typescript
// features/sys/users/hooks/useUsers.ts

import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { userService } from '../services/userService';

const USERS_QUERY_KEY = ['users'] as const;

// 목록 조회
export function useUsers(params?: UserQueryParams) {
  return useQuery({
    queryKey: [...USERS_QUERY_KEY, params],
    queryFn: () => userService.listUsers(params),
    staleTime: 5 * 60 * 1000, // 5분
    gcTime: 10 * 60 * 1000,   // 10분
  });
}

// 상세 조회
export function useUser(id: string | null | undefined) {
  return useQuery({
    queryKey: [...USERS_QUERY_KEY, 'detail', id],
    queryFn: () => userService.getUser(id!),
    enabled: !!id,
  });
}

// 생성
export function useCreateUser() {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: CreateUserRequest) => userService.createUser(data),
    onSuccess: () => {
      // 목록 쿼리 무효화하여 자동 리페치
      queryClient.invalidateQueries({ queryKey: USERS_QUERY_KEY });
    },
  });
}

// 수정
export function useUpdateUser(id: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: (data: UpdateUserRequest) => userService.updateUser(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: USERS_QUERY_KEY });
      queryClient.invalidateQueries({
        queryKey: [...USERS_QUERY_KEY, 'detail', id],
      });
    },
  });
}

// 삭제
export function useDeleteUser(id: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: () => userService.deleteUser(id),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: USERS_QUERY_KEY });
    },
  });
}
```

### 4. Components 계층

**파일**: `features/[schema]/[entity]/components/[Component].tsx`

**목적**: UI 표현 및 사용자 상호작용

**구현된 컴포넌트** (sys/users 예시):
- `UserList.tsx`: 목록 표시, 페이지네이션, 검색
- `UserListItem.tsx`: 개별 항목, 액션 버튼
- `UserCreateForm.tsx`: 생성 폼
- `UserEditForm.tsx`: 수정 폼

**예시**:
```typescript
// features/sys/users/components/UserList.tsx

'use client';

import { useState } from 'react';
import { useUsers } from '../hooks/useUsers';
import { UserListItem } from './UserListItem';
import { UserCreateForm } from './UserCreateForm';

export function UserList() {
  const [params, setParams] = useState<UserQueryParams>({ page: 1, pageSize: 10 });
  const [showCreateForm, setShowCreateForm] = useState(false);
  const { data, isLoading, error } = useUsers(params);

  if (isLoading) return <div>로딩 중...</div>;
  if (error) return <div>에러: {error.message}</div>;

  return (
    <div className="space-y-6">
      <div className="flex justify-between">
        <input
          type="text"
          placeholder="검색..."
          onChange={(e) => setParams(p => ({ ...p, search: e.target.value, page: 1 }))}
          className="px-4 py-2 border rounded"
        />
        <button
          onClick={() => setShowCreateForm(!showCreateForm)}
          className="px-4 py-2 bg-blue-500 text-white rounded"
        >
          새 사용자 추가
        </button>
      </div>

      {showCreateForm && <UserCreateForm onSuccess={() => setShowCreateForm(false)} />}

      <div className="space-y-4">
        {data?.data.map(user => <UserListItem key={user.id} user={user} />)}
      </div>
    </div>
  );
}
```

## CRUD 작업 흐름

### Create (생성)

```typescript
// 페이지에서 사용
const { mutate, isPending } = useCreateUser();

const handleSubmit = (data: CreateUserRequest) => {
  mutate(data, {
    onSuccess: () => {
      // UI 업데이트 (자동 처리됨)
      alert('사용자가 생성되었습니다.');
    },
  });
};
```

### Read (조회)

```typescript
// 목록 조회
const { data, isLoading } = useUsers({ page: 1, pageSize: 10 });

// 상세 조회
const { data: user } = useUser(userId);
```

### Update (수정)

```typescript
const { mutate } = useUpdateUser(userId);

const handleUpdate = (data: UpdateUserRequest) => {
  mutate(data, {
    onSuccess: () => {
      alert('사용자가 수정되었습니다.');
    },
  });
};
```

### Delete (삭제)

```typescript
const { mutate } = useDeleteUser(userId);

const handleDelete = () => {
  if (confirm('정말 삭제하시겠습니까?')) {
    mutate();
  }
};
```

## API 엔드포인트 매핑

| 기능 | 메서드 | 엔드포인트 |
|------|--------|-----------|
| 목록 조회 | GET | `/api/22_sys/users` |
| 상세 조회 | GET | `/api/22_sys/users/:id` |
| 생성 | POST | `/api/22_sys/users` |
| 수정 | PATCH | `/api/22_sys/users/:id` |
| 삭제 | DELETE | `/api/22_sys/users/:id` |

## 구현된 엔티티 목록

### 완전 구현 (Types + Services + Hooks + Components)
- ✅ `sys/users` - 사용자 관리 (완전 예시)
- ✅ `crm/partners` - 거래처 관리

### 부분 구현 (Types + Services + Hooks)
- `crm/opportunities` - 영업 기회
- `crm/activities` - 활동
- `pim/products` - 제품
- `ivm/inventory-balances` - 재고 잔액
- `psm/purchase-orders` - 구매주문
- `srm/sales-orders` - 판매주문
- `fim/accounts` - 계정
- `adm/codes` - 코드

### 폴더 구조만 생성
- 나머지 모든 엔티티

## 페이지에서 사용 예시

### users 페이지
```typescript
// app/(main)/sys/users/page.tsx

'use client';

import { UserList } from '@/features/sys/users';

export default function UsersPage() {
  return (
    <div className="container mx-auto py-10">
      <h1 className="text-3xl font-bold mb-6">사용자 관리</h1>
      <UserList />
    </div>
  );
}
```

### partners 페이지
```typescript
// app/(main)/crm/partners/page.tsx

'use client';

import { usePartners } from '@/features/crm/partners';

export default function PartnersPage() {
  const [params, setParams] = useState({ page: 1, pageSize: 10 });
  const { data, isLoading } = usePartners(params);

  return (
    <div className="container mx-auto py-10">
      <h1 className="text-3xl font-bold mb-6">거래처 관리</h1>
      {/* 파트너 목록 표시 */}
    </div>
  );
}
```

## 패턴 및 규칙

### 1. 파일명 규칙
- **Services**: `[entity]Service.ts` (예: `userService.ts`, `partnerService.ts`)
- **Hooks**: `use[Entity].ts` (예: `useUsers.ts`, `usePartners.ts`)
- **Components**: `[Entity][Action].tsx` (예: `UserList.tsx`, `UserCreateForm.tsx`)

### 2. Query Key 규칙
```typescript
const ENTITY_QUERY_KEY = ['entityName'] as const;

// 목록
[...ENTITY_QUERY_KEY, params]

// 상세
[...ENTITY_QUERY_KEY, 'detail', id]

// 캐시 무효화
queryClient.invalidateQueries({ queryKey: ENTITY_QUERY_KEY })
```

### 3. API URL 패턴
```typescript
const API_ENDPOINT = `${API_BASE_URL}/api/[schemaNumber]_[schemaName]/[entityName]`;

// 예시
const API_ENDPOINT = `${API_BASE_URL}/api/22_sys/users`;
const API_ENDPOINT = `${API_BASE_URL}/api/03_crm/partners`;
```

### 4. 에러 처리
모든 서비스 메서드는 try-catch로 감싸져 있으며, 에러를 콘솔에 로깅하고 throw합니다.

```typescript
try {
  // API 호출
  return response.data;
} catch (error) {
  console.error('Error:', error);
  throw error;
}
```

## 향후 개선사항

### Phase 1 - 컴포넌트 완성
- [ ] 모든 엔티티에 List, CreateForm, EditForm 컴포넌트 추가
- [ ] 공유 테이블 컴포넌트 생성 (정렬, 필터, 페이징)
- [ ] 공유 폼 컴포넌트 생성 (입력, 검증)

### Phase 2 - 상태 관리
- [ ] Zustand 스토어 추가 (필요시)
- [ ] 전역 필터 상태 관리
- [ ] 선택 항목 관리

### Phase 3 - 고급 기능
- [ ] Optimistic Updates 구현
- [ ] 벌크 작업 (다중 삭제, 상태 변경)
- [ ] 내보내기/가져오기
- [ ] 고급 검색 및 필터

### Phase 4 - 테스트
- [ ] 각 계층별 유닛 테스트
- [ ] 통합 테스트
- [ ] E2E 테스트

## 요약

```
Features 폴더 구조:
src/features/
├── [schema]/               # 비즈니스 도메인 (adm, crm, pim, ...)
│   └── [entity]/           # 데이터 엔티티 (users, partners, products, ...)
│       ├── types/          # TypeScript 타입
│       ├── services/       # API 서비스
│       ├── hooks/          # React Query 훅
│       ├── components/     # React 컴포넌트
│       └── index.ts        # 공개 API

데이터 흐름:
Page → Components → Hooks → Services → API

캐싱 전략:
- staleTime: 5분 (데이터가 fresh 상태 유지 시간)
- gcTime: 10분 (가비지 컬렉션 대기 시간)
- 캐시 무효화: mutate 성공 시 자동 실행

장점:
✅ 명확한 책임 분리
✅ 높은 재사용성
✅ 좋은 테스트 가능성
✅ 타입 안정성
✅ 자동 캐싱 및 동기화
```
